


/* ============================================================
   🧠 جلسه پانزدهم — توابع و ویوها در SQL Server
   ============================================================

   📌 محورهای اصلی آموزش در این جلسه:

   🔹 توابع اسکالر (Scalar-valued Function - SVF)
       - ایجاد توابع با خروجی تک‌مقداری مثل جمع فروش برای ناشر خاص، یا یک عنوان خاص
       - نمونه‌هایی از فراخوانی تابع در SELECT و GROUP BY

   🔹 ویوها (Views)
       - تعریف و استفاده از ویو برای ساده‌سازی کوئری‌های فروش
       - مقایسهٔ عملکرد ویوها با Table-Valued Function

   🔹 توابع جدولی (Table-Valued Functions - TVF)
       - تعریف انواع مختلف TVF شامل:
           ✅ TVF بدون ورودی (مثل tvfSales)
           ✅ TVF با ورودی برای Publisher، Title، و Type
           ✅ TVF با Aggregation در GROUP BY
       - مثال‌هایی برای استفاده از TVF در کوئری‌های پیچیده و JOIN

   📈 نکات عملکردی و حرفه‌ای:
       ✅ تفاوت SVF و TVF در اجرا و پرفورمنس (TVFها معمولاً بهینه‌ترند)
       ✅ ویوها و TVF از نظر کدنویسی و کاربرد مشابه‌اند، ولی مدیریت‌شان در سطح سرور متفاوت است
       ✅ توابع چندبیانی (Multi-statement TVF) برای منطق پیچیده‌تر قابل توسعه‌اند

   🛠️ این جلسه زمینه‌ساز استفاده پیشرفته از ماژولار بودن SQL است تا کد خواناتر، نگهداشت‌پذیرتر و قابل استفاده مجدد نوشته شود.

============================================================ */



------------------------------------------------------------------



USE T_pubs
GO



------------------------------------------------------------------



/* ============================================================
   1️⃣ تعریف تابع Scalar برای محاسبه مجموع فروش هر ناشر
   ============================================================

📌 در این بخش یک تابع مقدار اسکالر (`Scalar-valued Function`) به نام `svfPublishersAmount` ایجاد می‌شود.
📌 این تابع با گرفتن `pub_id` ناشر، مجموع درآمد حاصل از فروش کتاب‌های منتشر شده توسط آن ناشر را محاسبه می‌کند.

🔧 استفاده:
تابع در کوئری‌های بعدی قابل استفاده است و می‌تواند به عنوان یک فیلد محاسباتی در SELECT مورد استفاده قرار گیرد.
*/

CREATE OR ALTER FUNCTION svfPublishersAmount(@PubID char(4))
RETURNS money
AS
BEGIN
	RETURN (
		SELECT SUM(qty * price)
		FROM titles t
		INNER JOIN sales s ON s.title_id = t.title_id
		WHERE pub_id = @PubID
	)
END
GO

SELECT pub_id, pub_name, dbo.svfPublishersAmount(pub_id)
FROM publishers
GO

-- 📈 نکات پرفورمنسی:
-- تابع اسکالر در هر ردیف از کوئری فراخوانی می‌شود که در دیتاست‌های بزرگ می‌تواند منجر به کاهش کارایی شود.
-- در چنین مواردی بهتر است از `JOIN` و `GROUP BY` مستقیم در کوئری استفاده شود.



------------------------------------------------------------------



/* ============================================================
   2️⃣ تعریف تابع Scalar برای محاسبه مجموع فروش بر اساس نوع کتاب
   ============================================================

📌 این تابع اسکالر (`Scalar-valued Function`) با نام `svfTypeAmount` تعریف شده است.
📌 وظیفه‌ی این تابع محاسبه مجموع مبلغ فروش کتاب‌هایی است که از نوع مشخص شده (`type`) هستند.

🔧 ورودی:
- `@type` نوع کتاب (مثلاً 'business', 'mod_cook', ...)

🔧 خروجی:
- مجموع فروش بر اساس نوع کتاب

🔍 استفاده در کوئری: این تابع به ازای هر `type` موجود در جدول titles، مقدار فروش آن را برمی‌گرداند.
*/

CREATE OR ALTER FUNCTION svfTypeAmount(@type char(12))
RETURNS money
AS
BEGIN
	RETURN (
		SELECT SUM(qty * price)
		FROM titles t
		INNER JOIN sales s ON s.title_id = t.title_id
		WHERE type = @type
	)
END
GO

SELECT DISTINCT type, dbo.svfTypeAmount(type)
FROM titles
GO

-- 📈 نکات پرفورمنسی:
-- مشابه تابع قبلی، این تابع در هر ردیف اجرا می‌شود و این تکرار می‌تواند در دیتاست‌های بزرگ تأثیر منفی بر کارایی داشته باشد.
-- در صورت نیاز به بهینه‌سازی، پیشنهاد می‌شود از JOIN و GROUP BY در یک کوئری جداگانه استفاده شود.



------------------------------------------------------------------



/* ============================================================
   3️⃣ محاسبه سهم هر نویسنده از فروش بر اساس تعداد نویسندگان هر کتاب
   ============================================================

📌 در این کوئری، برای هر نویسنده مجموع سهم او از فروش کتاب‌ها محاسبه می‌شود.
📌 فرض بر این است که اگر یک کتاب چند نویسنده داشته باشد، درآمد آن بین همه‌ی نویسندگان به صورت مساوی تقسیم می‌شود.

🧠 نحوه محاسبه:
- از تابع `svfAmount` برای محاسبه مجموع فروش هر کتاب استفاده می‌شود.
- از تابع `svfTitleAuCo` برای شمارش تعداد نویسندگان هر کتاب استفاده می‌شود.
- حاصل تقسیم این دو عدد، سهم نویسنده از آن کتاب را نشان می‌دهد.

📊 خروجی:
- کد نویسنده، نام، نام خانوادگی، و مجموع سهم او از فروش کلیه کتاب‌هایی که در آن مشارکت داشته است.
*/

SELECT a.au_id, au_fname, au_lname,
       SUM(dbo.svfAmount(title_id) / dbo.svfTitleAuCo(title_id))
FROM titleauthor l
INNER JOIN authors a ON l.au_id = a.au_id
GROUP BY a.au_id, au_fname, au_lname
GO

-- ⚠️ نکات پرفورمنسی:
-- اجرای توابع `svfAmount` و `svfTitleAuCo` برای هر ردیف از `titleauthor` ممکن است باعث کاهش پرفورمنس شود.
-- اگر این محاسبات بر روی دیتاست‌های بزرگ انجام شود، توصیه می‌شود از CTE یا TVFهای بهینه‌ شده استفاده گردد.



------------------------------------------------------------------



/* ============================================================
   4️⃣ ایجاد و استفاده از ویو (View) برای ساده‌سازی گزارش فروش
   ============================================================

📌 در این بخش یک View با نام `vwSale` ایجاد می‌شود که اطلاعات فروش از جدول‌های `titles` و `sales` را ترکیب می‌کند.
📌 این View به عنوان یک منبع داده‌ی قابل استفاده برای گزارش‌گیری‌های مختلف طراحی شده است.

🎯 مزایا:
- افزایش خوانایی و سادگی کوئری‌های گزارش‌گیری
- کاهش تکرار کدهای Join در کوئری‌های متعدد

📊 نمونه استفاده‌ها:
1. محاسبه فروش هر عنوان کتاب با `SUM(qty * price)`.
2. گزارش فروش بر اساس فیلتر `type = 'business'`.
3. گزارش فروش کل برای هر ناشر با Join به جدول `publishers`.

*/



CREATE OR ALTER VIEW vwSale
AS
	SELECT t.title_id, title, pub_id, type, price, qty, ord_date
	FROM titles t
	INNER JOIN sales s ON t.title_id = s.title_id
GO



-- 📌 مجموع فروش برای هر عنوان
SELECT title_id, title, SUM(qty * price)
FROM vwSale
GROUP BY title_id, title



-- 📌 مجموع فروش برای کتاب‌های نوع 'business'
SELECT title_id, title, SUM(qty * price)
FROM vwSale
WHERE type = 'business'
GROUP BY title_id, title



-- 📌 مجموع فروش برای هر ناشر
SELECT p.pub_id, pub_name, SUM(qty * price)
FROM vwSale v
INNER JOIN publishers p ON v.pub_id = p.pub_id
GROUP BY p.pub_id, pub_name
GO



-- 📌 بررسی صحت داده‌های vwSale در مقابل Join مستقیم
SELECT t.title_id, title, pub_id, type, price, qty, ord_date
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id



-- 📌 خروجی View به طور مستقیم
SELECT *
FROM vwSale



-- 📌 گزارش فروش ناشر مجدداً برای مقایسه
SELECT p.pub_id, pub_name, SUM(qty * price)
FROM vwSale v
INNER JOIN publishers p ON v.pub_id = p.pub_id
GROUP BY p.pub_id, pub_name
GO



-- ✅ نکات پرفورمنسی:
-- استفاده از View پیچیدگی کوئری‌ها را کم می‌کند اما پرفورمنس به نوع استفاده بستگی دارد.
-- اگر View در کوئری‌های پیچیده تو در تو استفاده شود ممکن است بهینه‌سازی توسط SQL Engine سخت‌تر شود.



------------------------------------------------------------------



/* ============================================================
   5️⃣ ساخت View تجمیعی برای مقادیر فروش به ازای هر کتاب
   ============================================================

📌 در این بخش View دیگری با نام `vwAmount` ساخته می‌شود که از View قبلی یعنی `vwSale` استفاده می‌کند.
📌 این View اطلاعات فروش تجمیعی (Amount) را به ازای هر `title_id` محاسبه کرده و خروجی می‌دهد.

🎯 مزایا:
- جدا کردن منطق محاسبه مقدار فروش در یک View مجزا
- سادگی و قابلیت استفاده مجدد در گزارش‌ها و تحلیل‌های بعدی

📊 کاربردها:
1. مشاهده کل فروش به ازای هر عنوان کتاب
2. محاسبه مجموع فروش ناشرین با استفاده از این View

*/

CREATE OR ALTER VIEW vwAmount
AS
	SELECT title_id, title, pub_id, type, SUM(qty * price) AS Amount
	FROM vwSale
	GROUP BY title_id, title, pub_id, type
GO



-- 📌 مشاهده فروش هر کتاب به همراه جزئیات
SELECT *
FROM vwAmount



-- 📌 محاسبه مجموع فروش ناشرین با استفاده از vwAmount
SELECT p.pub_id, pub_name, SUM(Amount)
FROM publishers p
INNER JOIN vwAmount s ON p.pub_id = s.pub_id
GROUP BY p.pub_id, pub_name
GO

-- ✅ نکات پرفورمنسی:
-- استفاده از Viewهای تو در تو (vwSale و سپس vwAmount) می‌تواند منطق را خواناتر کند ولی بسته به حجم داده، بر عملکرد تأثیر می‌گذارد.
-- برای گزارش‌گیری‌های بزرگ بهتر است روی ایندکس‌ها یا Materialized View فکر شود.



------------------------------------------------------------------



/* ============================================================
   6️⃣ ساخت View جهت ارتباط بین کتاب‌ها و نویسندگان
   ============================================================

📌 این View با نام `vwTitleAuthor` برای نمایش اطلاعات ترکیبی کتاب‌ها و نویسندگان استفاده می‌شود.
📚 داده‌ها از سه جدول `titles`، `titleauthor` و `authors` ترکیب می‌شوند.

🎯 هدف:
- نمایش نویسندگان هر کتاب با نام و نام خانوادگی آن‌ها
- آماده‌سازی داده‌ها برای عملیات‌های ترکیبی و گزارش‌گیری

📊 کاربرد نهایی:
- استفاده از `STRING_AGG` برای تجمیع نام نویسندگان مرتبط با هر کتاب

*/

CREATE OR ALTER VIEW vwTitleAuthor
AS
	SELECT t.title_id, title, a.au_id, au_fname, au_lname
	FROM titles t
	INNER JOIN titleauthor l ON t.title_id = l.title_id
	INNER JOIN authors a ON a.au_id = l.au_id
GO



-- 📌 نمایش لیست نویسندگان هر کتاب در یک رشته تجمیعی
SELECT title_id, title, STRING_AGG(au_fname + '' + au_lname, ' - ')
FROM vwTitleAuthor
GROUP BY title_id, title
GO
-- ✅ نکات پرفورمنسی:
-- استفاده از View برای ساده‌سازی کوئری‌های چند جدولی بسیار مفید است.
-- توابع تجمیعی مانند `STRING_AGG` در SQL Server 2017 به بعد در دسترس‌اند و می‌توانند خوانایی و کارایی خروجی را بهبود دهند.



------------------------------------------------------------------



/*


	SCALER VALUE FUNCTION -> svf

										CREATE OR ALTER FUNCTION svfName(@Par1 DT , ...)
										RETURNS DataType
										AS
										BEGIN
													RETURN (EXPR)
										END
										GO

	TABLE VALUE FUNCTION -> tvf

						INLINE
						MULTI STATEMENT	
									
										CREATE OR ALTER FUNCTION tvfName(@Par1 DT , ...)
										RETURNS TABLE
										
													RETURN (EXPR)
										GO


*/



------------------------------------------------------------------



/* ============================================================
   7️⃣ ایجاد Inline Table-Valued Function (TVF) برای فروش‌ها
   ============================================================

📌 در این بخش یک تابع مقداردهی جدولی (TVF) با نام `tvfSales` ایجاد می‌شود.
📦 این تابع اطلاعات فروش از جدول `titles` و `sales` را ترکیب می‌کند و نتیجه را به صورت یک جدول بازمی‌گرداند.

🎯 کاربرد:
- ساده‌سازی استفاده مجدد از کوئری‌های پرتکرار
- افزایش خوانایی کوئری‌ها هنگام نیاز به پیوستن یا فیلتر کردن داده‌های فروش

📊 عملیات‌های انجام شده:
1. نمایش کلیه رکوردهای برگشتی توسط `tvfSales()`
2. محاسبه مجموع فروش برای هر کتاب
3. ترکیب نتایج تابع با جدول `publishers` برای گزارش‌های ترکیبی

*/

CREATE FUNCTION tvfSales()
RETURNS TABLE
RETURN (
	SELECT t.title_id, title, pub_id, type, price, qty, ord_date
	FROM titles t
	INNER JOIN sales s ON t.title_id = s.title_id
)
GO

-- 🔍 مشاهده تمامی رکوردهای فروش
SELECT * FROM tvfSales()

-- 📊 محاسبه مجموع فروش برای هر کتاب
SELECT title_id, title, SUM(qty * price)
FROM tvfSales()
GROUP BY title_id, title

-- 🔗 پیوستن به جدول ناشران برای تحلیل‌های دقیق‌تر
SELECT *
FROM tvfSales() INNER JOIN
	 publishers p ON tvfSales.pub_id = p.pub_id
GO
-- ✅ نکات پرفورمنسی:
-- توابع `Inline TVF` به دلیل اینکه مستقیماً در execution plan جایگزین می‌شوند، بسیار سریع‌تر از Multi-Statement TVF ها اجرا می‌گردند.
-- استفاده از `TVF` باعث می‌شود کوئری‌ها ماژولارتر و قابل نگهداری‌تر باشند.



------------------------------------------------------------------



/* ============================================================
   8️⃣ تعریف Inline TVF برای محاسبه مجموع فروش هر عنوان کتاب
   ============================================================

📌 در این قسمت تابع جدولی `tvfAmount` ساخته می‌شود که مجموع فروش (تعداد * قیمت) هر کتاب را محاسبه کرده و بازمی‌گرداند.

🧾 پارامتر ورودی ندارد و خروجی آن شامل فیلدهای `title_id`, `title`, `type`, `pub_id` و `Amount` (مقدار فروش) است.

🎯 اهداف:
- افزایش قابلیت استفاده مجدد از کوئری
- تسهیل در نوشتن گزارش‌ها یا انجام تحلیل‌های پیچیده

🔍 مقایسه با View:
- تابع `tvfAmount()` و ویو `vwAmount` از لحاظ عملکرد مشابه هستند و نتایج یکسانی ارائه می‌دهند.
- با این حال، TVFها قابل پارامتر دهی هستند و در برخی سناریوها منعطف‌تر از ویوها عمل می‌کنند.

*/

CREATE OR ALTER FUNCTION tvfAmount()
RETURNS TABLE
RETURN (
	SELECT t.title_id, title, type, pub_id, SUM(qty * price) AS Amount
	FROM titles t
	INNER JOIN sales s ON t.title_id = s.title_id
	GROUP BY t.title_id, title, type, pub_id
)
GO

-- نمایش نتایج حاصل از تابع
SELECT * FROM tvfAmount()

-- مقایسه با ویو تعریف‌شده مشابه
SELECT * FROM vwAmount
GO
-- ⚠️ نکته:
-- TVF با قابلیت پارامتر‌پذیری در آینده، انعطاف‌پذیری بیشتری نسبت به View فراهم می‌کند.
-- عملکرد View و Inline TVF در اجرا مشابه بوده و هردو می‌توانند در کوئری‌ها به خوبی استفاده شوند.



-----------------------------------------------------------------------



/* ============================================================
   9️⃣ تابع جدولی برای شمارش نویسندگان هر عنوان کتاب
   ============================================================

📌 در این بخش، یک تابع جدولی به نام `tvfTitleAu` تعریف شده که تعداد نویسندگان (CoAU) مرتبط با هر کتاب را مشخص می‌کند.

📋 خروجی تابع:
- `title_id`: شناسه عنوان
- `title`: نام کتاب
- `CoAU`: تعداد نویسندگان مربوط به آن عنوان

🎯 کاربرد:
- برای تحلیل میزان مشارکت نویسندگان در تألیف کتاب‌ها
- استفاده در گزارشات و تجزیه و تحلیل‌های سطح بالا

✅ مزیت:
- ساده‌سازی و جداسازی منطق استخراج نویسنده‌ها در قالب تابع قابل استفاده مجدد

*/

CREATE OR ALTER FUNCTION tvfTitleAu()
RETURNS TABLE
RETURN (
	SELECT t.title_id, title, COUNT(*) AS CoAU
	FROM titles t
	INNER JOIN titleauthor a ON t.title_id = a.title_id
	GROUP BY t.title_id, title
)
GO

-- 🔍 مشاهده خروجی تابع
SELECT * FROM tvfTitleAu()
GO



------------------------------------------------------------------



/* ============================================================
   🔟 تابع جدولی پارامتری برای محاسبه فروش ناشر خاص
   ============================================================

📌 در این بخش، تابع جدولی `tvfPublishersAmount` تعریف شده که با دریافت `PubID`، مجموع فروش (مقدار حاصل از قیمت × تعداد) را برای ناشر مربوطه محاسبه می‌کند.

🧮 پارامتر ورودی:
- `@PubID`: شناسه ناشر

📋 خروجی:
- `Amount`: مجموع مبلغ فروش کتاب‌های ناشر مذکور

🎯 کاربرد:
- تحلیل عملکرد فروش ناشران
- استفاده در گزارش‌گیری‌های داینامیک

🔧 نکته:
- برخلاف توابع مقدار اسکالر (SVF)، توابع جدول پارامتری (TVF) می‌توانند در کوئری‌های پیچیده‌تر بهتر اجرا شوند و ایندکس‌پذیر باقی بمانند.

*/

CREATE OR ALTER FUNCTION tvfPublishersAmount (@PubID char(4))
RETURNS TABLE
RETURN
(
	SELECT SUM(qty * price) AS Amount
	FROM titles t
	INNER JOIN sales s ON s.title_id = t.title_id
	WHERE pub_id = @PubID
)
GO

-- 🎯 بررسی خروجی تابع با PubID خاص
SELECT * FROM tvfPublishersAmount('0736')

-- 🆚 مقایسه با نسخه اسکالر همین تابع
SELECT pub_name, dbo.svfPublishersAmount(pub_id)
FROM publishers
GO


-- ⚙️ نکات پرفورمنسی:
-- ✅ تابع TVF چون `INLINE` هست و فقط یک `SELECT` ساده داره، معمولاً عملکرد خیلی بهتری نسبت به توابع اسکالر (`SVF`) داره.
-- ✅ می‌تونه در ترکیب با سایر جداول و کوئری‌ها بدون افت کارایی زیاد استفاده بشه.
-- ❌ اما اگر در کوئری‌های خیلی سنگین چندباره فراخوانی بشه، بهتره به جای اجرای مجدد، مقدار خروجی رو یک بار در یک CTE ذخیره کنیم.
-- ⚠️ همچنین روی فیلترها و JOINهای سنگین اگر PubID ایندکس نداشته باشه ممکنه باعث Full Scan روی `titles` و `sales` بشه.



------------------------------------------------------------------



/* ============================================================
   🔟 تابع جدولی پارامتری برای محاسبه فروش یک عنوان خاص
   ============================================================

📌 در این بخش، تابع `tvfTitleAmount` تعریف شده که با دریافت شناسه‌ی عنوان (`title_id`)، مجموع فروش (قیمت × تعداد) را برای آن عنوان خاص محاسبه می‌کند.

🧮 پارامتر ورودی:
- `@ID`: شناسه عنوان (title_id)

📋 خروجی:
- `Amount`: مجموع فروش عنوان مورد نظر

🎯 کاربرد:
- بررسی دقیق فروش هر کتاب
- مقایسه درآمد حاصل از هر عنوان
- ایجاد گزارش‌های تفکیکی بر اساس عنوان

🔧 نکته:
- این تابع از نوع inline TVF است و عملکرد بهتری نسبت به SVF دارد، به‌ویژه در ترکیب با سایر کوئری‌ها و جوین‌ها.
*/

CREATE OR ALTER FUNCTION tvfTitleAmount (@ID varchar(6))
RETURNS TABLE
RETURN
		(SELECT SUM(qty * price) Amount
			FROM titles t INNER JOIN
				 sales s ON t.title_id = s.title_id
			WHERE t.title_id = @ID)
GO

SELECT *
	FROM tvfTitleAmount('BU1032')
GO
-- 💡 نکات پرفورمنسی:
-- ✅ TVF از نوع inline بوده و به دلیل اجرا در سطح کوئری پلن اصلی، از سرعت بهتری برخوردار است.
-- ✅ اجرای مؤثر همراه با ایندکس روی `title_id`.
-- ❗ برای استفاده‌های مکرر بهتر است بررسی شود که توزیع داده‌ها متوازن باشد.



------------------------------------------------------------------



/* ============================================================
   1️⃣ تابع اسکالر برای محاسبه مجموع فروش یک عنوان
   ============================================================

📌 در این بخش، تابع `svfAmount` معرفی شده که با دریافت شناسه‌ی عنوان (`title_id`)، مجموع فروش آن را محاسبه و برمی‌گرداند.

🧮 پارامتر ورودی:
- `@title_id`: شناسه عنوان (کتاب)

📋 خروجی:
- `money`: مجموع فروش (قیمت × تعداد)

🎯 کاربرد:
- استفاده در گزارش‌های تجمیعی فروش برای هر عنوان
- تحلیل عملکرد فروش هر کتاب به صورت جداگانه

🔧 ساختار:
- این تابع از نوع `Scalar Value Function` (SVF) است و مقدار واحدی برمی‌گرداند.
*/

CREATE FUNCTION svfAmount (@title_id varchar(6))
RETURNS money
AS
BEGIN 
	DECLARE @Result money = (
		SELECT SUM(qty * price)
		FROM titles t
		INNER JOIN sales s ON s.title_id = t.title_id
		WHERE t.title_id = @title_id
	)
	RETURN @Result
END 
GO

SELECT title_id , title , dbo.svfAmount(title_id)
	FROM titles
GO
-- 💡 نکات پرفورمنسی:
-- ⚠️ توابع اسکالر در SQL Server ممکن است عملکرد ضعیفی در کوئری‌های بزرگ داشته باشند، به دلیل فراخوانی مجزای هر رکورد.
-- ✅ توصیه می‌شود برای تحلیل‌های وسیع‌تر از TVF (تابع جدولی) به جای SVF استفاده شود تا از مزایای inline execution بهره‌مند شوید.



------------------------------------------------------------------



/* ============================================================
   2️⃣ تابع جدولی پارامتری برای محاسبه مجموع فروش بر اساس نوع کتاب
   ============================================================

📌 تابع `tvfTypeAmount` مجموع فروش کتاب‌ها را بر اساس نوع (Type) مشخص‌شده محاسبه می‌کند.

🧮 پارامتر ورودی:
- `@type`: نوع کتاب (مانند 'business', 'mod_cook' و ...)

📋 خروجی:
- `Amount`: مجموع مبلغ فروش کتاب‌ها از نوع مشخص‌شده

🎯 کاربرد:
- تحلیل فروش بر اساس ژانر یا دسته‌بندی کتاب‌ها
- استفاده در داشبوردهای مدیریتی فروش برای مقایسه‌ی بین انواع محتوا

🔧 ویژگی:
- تابع از نوع Table-Valued Function (TVF) است که قابل استفاده در کوئری‌های پیچیده و قابل بهینه‌سازی توسط موتور SQL می‌باشد.
*/

CREATE OR ALTER FUNCTION tvfTypeAmount (@type char(12))
RETURNS TABLE
RETURN
		(SELECT SUM(qty * price) Amount
			FROM titles t INNER JOIN
				 sales s ON t.title_id = s.title_id
			WHERE type = @type)
GO

SELECT *
	FROM tvfTitleAmount('business')
GO
-- 💡 نکات پرفورمنسی:
-- ✅ TVF نسبت به SVF عملکرد بهتری دارد چرا که می‌تواند در execution plan به صورت inline اجرا شود.
-- ⚠️ اطمینان حاصل شود که فیلد `type` ایندکس‌گذاری شده باشد، مخصوصاً در دیتاست‌های بزرگ برای افزایش سرعت.



------------------------------------------------------------------



/* ============================================================
   3️⃣ تابع جدولی پارامتری برای محاسبه فروش کتاب‌ها بر اساس نوع
   ============================================================

📌 در این بخش، تابع `tvfTitleTypeAmount` طراحی شده تا برای هر عنوان کتاب از نوع خاص، مجموع مبلغ فروش را محاسبه کند.

🧮 پارامتر ورودی:
- `@type`: نوع کتاب (مثلاً 'mod_cook', 'business', و ...)

📋 خروجی:
- `title_id`: شناسه کتاب
- `title`: نام کتاب
- `Amount`: مجموع فروش (تعداد * قیمت) برای آن عنوان خاص

🎯 کاربرد:
- گزارش‌گیری و تحلیل دقیق‌تر از فروش به تفکیک عنوان‌های مرتبط با یک دسته خاص
- بررسی عملکرد هر کتاب در هر ژانر

🔧 مزیت:
- استفاده از TVF باعث بالا رفتن خوانایی کوئری و بهبود عملکرد نسبت به توابع اسکالر می‌شود، مخصوصاً هنگام استفاده در Joins یا Subqueryها.
*/

CREATE OR ALTER FUNCTION tvfTitleTypeAmount (@type char(12))
RETURNS TABLE
RETURN
		(SELECT t.title_id , title , SUM(qty * price) Amount
			FROM titles t INNER JOIN
				 sales s ON t.title_id = s.title_id
			WHERE type = @type
			GROUP BY t.title_id , title)
GO

SELECT *
	FROM tvfTitleAmount('mod_cook')

-- 💡 نکات پرفورمنسی:
-- ✅ استفاده از GROUP BY روی `title_id` و `title` در کوئری باعث ایجاد خلاصه‌ای از فروش برای هر کتاب می‌شود.
-- ⚠️ ایندکس‌گذاری روی فیلدهای `type` و `title_id` می‌تواند سرعت کوئری را در دیتابیس‌های بزرگ افزایش دهد.
-- 🚀 در مقایسه با subquery یا joinهای متعدد، TVF ساده‌تر، ایمن‌تر و قابل نگهداری‌تر است.

