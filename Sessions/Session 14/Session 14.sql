


/* ===================================================================================================
   📚 خلاصه جلسه چهاردهم - SQL Server Training

   ✅ این جلسه با تمرکز بر تکنیک‌های پیشرفته در دستورات DML (Data Manipulation Language) برگزار شد.
   سرفصل‌ها و تکنیک‌های بررسی‌شده عبارت‌اند از:

   🔧 UPDATE پیشرفته:
       - استفاده از CASE برای اعمال منطق شرطی در بروزرسانی داده‌ها
       - استفاده از اطلاعات ترکیبی چند جدول با INNER JOIN در عملیات UPDATE
       - استفاده از CTE برای ساختاردهی بهتر منطق بروزرسانی

   📥 INSERT و ساخت جدول جدید:
       - ساخت جدول با SELECT INTO و استفاده مجدد از آن با INSERT
       - استفاده از OUTPUT برای گرفتن مقادیر درج‌شده

   🗑️ DELETE هدفمند:
       - حذف داده‌های تکراری با استفاده از ROW_NUMBER
       - حذف ایمن با بررسی وابستگی کلیدهای خارجی
       - حذف رکوردهای خاص با استفاده از CTE و شروط خاص

   🔄 MERGE:
       - استفاده از MERGE برای همگام‌سازی داده‌ها بین دو جدول با INSERT, UPDATE, DELETE
       - استفاده از SET IDENTITY_INSERT برای مدیریت مقادیر کلید اصلی در MERGE

   🧪 عملیات کنترلی و کمکی:
       - استفاده از دستورات IF، WHILE، DECLARE و SET برای کنترل روند اجرای اسکریپت
       - بررسی تفاوت‌های بین DELETE و TRUNCATE
       - استفاده از توابع سیستمی مانند GETDATE، FORMAT، ROUND، DATEDIFF و غیره

   🧮 توابع اسکالر تعریف‌شده توسط کاربر (User-defined scalar functions):
       - تعریف توابع برای محاسبه فروش کل یک کتاب (`svfAmount`)
       - تعریف توابع برای شمارش تعداد نویسندگان یک عنوان (`svfTitleAuCo`)

   📌 نکات مهم:
       - استفاده از FORMAT برای زیباسازی خروجی‌ها
       - بررسی و پردازش رشته‌ها با توابع CHARINDEX، LEFT، SUBSTRING و STRING_SPLIT
       - تبدیل نوع داده با CONVERT و CAST
       - بهینه‌سازی عملیات با استفاده از WINDOW FUNCTIONها و توابع تجمعی

   ⛳ این جلسه یکی از کامل‌ترین جلسات برای کار با داده‌ها و منطق پیچیده در SQL Server است.
=================================================================================================== */



USE pubs
GO



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   1️⃣ بروزرسانی قیمت کتاب‌ها بر اساس چند شرط مختلف
   ============================================================

   📌 این کوئری قیمت کتاب‌ها را با استفاده از شرط‌های متوالی به‌روزرسانی می‌کند:
   ──────────────────────────────────────────────────────────────
   ✅ اگر ناشر کتاب در ایالت "CA" باشد ➤ افزایش قیمت به میزان 20٪
   ✅ اگر کتاب دارای بیش از یک نویسنده باشد ➤ افزایش قیمت به میزان 15٪
   ✅ اگر مجموع درآمد فروش کتاب بیش از 200 باشد ➤ افزایش قیمت به میزان 10٪
   ❗ در غیر این‌صورت ➤ کاهش قیمت به میزان 1٪
   ──────────────────────────────────────────────────────────────
*/

UPDATE titles
SET price = CASE
               WHEN pub_id IN (SELECT pub_id
                               FROM publishers
                               WHERE state = 'CA') THEN price * 1.20
               WHEN title_id IN (SELECT title_id
                                 FROM titleauthor
                                 GROUP BY title_id
                                 HAVING COUNT(*) > 1) THEN price * 1.15
               WHEN title_id IN (SELECT title_id
                                 FROM sales
                                 GROUP BY title_id
                                 HAVING SUM(qty) * price > 200) THEN price * 1.10
               ELSE price * .99
            END

/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   🔹 استفاده از ساب‌کوئری‌های مستقل در هر شرط می‌تواند موجب اجرای مکرر و مصرف منابع شود.
   🔹 در حجم دیتای بالا، پیشنهاد می‌شود این منطق به کمک CTE یا JOIN بازنویسی شود.
   🔹 ترتیب شرط‌ها مهم است — بهتر است شرایطی که احتمال بیشتری دارند در ابتدا قرار گیرند.
   🔹 بررسی ایندکس‌ها روی ستون‌های pub_id، title_id، و state می‌تواند کارایی را بهبود دهد.
   ─────────────────────────────────────────────
*/


-------------------------------------------------------------------------------------------------------------



/* ============================================================
   2️⃣ بروزرسانی قیمت کتاب‌ها با استفاده از CTE برای بهبود ساختار
   ============================================================

   📌 در این روش، ابتدا قیمت جدید بر اساس شرایط مختلف در یک CTE محاسبه می‌شود:
   ──────────────────────────────────────────────────────────────
   ✅ اگر ناشر در ایالت "CA" باشد ➤ افزایش قیمت به میزان 20٪
   ✅ اگر کتاب بیش از یک نویسنده داشته باشد ➤ افزایش قیمت به میزان 15٪
   ✅ اگر درآمد فروش کتاب بیش از 200 باشد ➤ افزایش قیمت به میزان 10٪
   ❗ در غیر این‌صورت ➤ کاهش قیمت به میزان 1٪

   سپس این قیمت جدید با استفاده از `INNER JOIN` روی جدول اصلی اعمال می‌شود.
*/

;WITH CTE AS (
	SELECT title_id, 
	       CASE 
	           WHEN pub_id IN (SELECT pub_id FROM publishers WHERE state = 'CA') THEN price * 1.20
	           WHEN title_id IN (SELECT title_id FROM titleauthor GROUP BY title_id HAVING COUNT(*) > 1) THEN price * 1.15
	           WHEN title_id IN (SELECT title_id FROM sales GROUP BY title_id HAVING SUM(qty) * price > 200) THEN price * 1.10
	           ELSE price * .99
	       END AS NewPrice
	FROM titles
)

UPDATE titles
SET price = NewPrice
FROM titles
INNER JOIN CTE ON CTE.title_id = titles.title_id

/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   ✅ استفاده از CTE ساختار کوئری را واضح‌تر کرده و نگهداری آن را آسان‌تر می‌کند.
   ✅ به دلیل جداسازی منطق محاسبه از منطق بروزرسانی، خطایابی راحت‌تر است.
   ⚠️ اما ساب‌کوئری‌های تو در تو هنوز ممکن است منجر به کاهش کارایی شوند.
   ⚠️ اگر تعداد زیادی رکورد وجود داشته باشد، بررسی وجود ایندکس روی ستون‌های `pub_id`، `title_id` ضروری است.
   ─────────────────────────────────────────────
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   3️⃣ بروزرسانی قیمت کتاب‌ها با استفاده از JOIN و مقادیر محاسبه‌شده
   ============================================================

   📌 در این کوئری، اطلاعات لازم برای تصمیم‌گیری درباره‌ی قیمت جدید از طریق `INNER JOIN` به دست می‌آید:
   ──────────────────────────────────────────────────────────────
   ✅ اگر ناشر در ایالت "CA" باشد ➤ افزایش قیمت به میزان 20٪
   ✅ اگر کتاب بیش از یک نویسنده داشته باشد ➤ افزایش قیمت به میزان 15٪
   ✅ اگر حاصل‌ضرب مجموع تعداد فروش در قیمت بیشتر از 200 باشد ➤ افزایش قیمت به میزان 10٪
   ❗ در غیر این‌صورت ➤ کاهش قیمت به میزان 1٪

   سه زیرکوئری به ترتیب برای تعیین وضعیت ایالت، تعداد نویسندگان (CoAu)، و مجموع تعداد فروش (TotalQty) استفاده شده‌اند.
*/

UPDATE titles
SET price = CASE
               WHEN state = 'CA' THEN price * 1.20
               WHEN CoAu > 1 THEN price * 1.15
               WHEN TotalQty * price > 200 THEN price * 1.10
               ELSE price * .99
            END
FROM titles
INNER JOIN publishers ON publishers.pub_id = titles.pub_id
INNER JOIN (
	SELECT title_id, COUNT(*) AS CoAu
	FROM titleauthor
	GROUP BY title_id
) AS a ON a.title_id = titles.title_id
INNER JOIN (
	SELECT title_id, SUM(qty) AS TotalQty
	FROM sales
	GROUP BY title_id
) AS s ON s.title_id = titles.title_id

/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   ✅ استفاده از JOIN به جای ساب‌کوئری‌های تودرتو باعث بهبود عملکرد در دیتاست‌های بزرگ می‌شود.
   ✅ امکان بهره‌مندی از ایندکس روی ستون‌های `pub_id`، `title_id`، `qty` برای افزایش سرعت اجرا وجود دارد.
   🔄 برخلاف CTE، این روش در بعضی مواقع سریع‌تر عمل می‌کند چون فقط یک مرحله اجرای JOIN انجام می‌دهد.
   ─────────────────────────────────────────────
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   4️⃣ ایجاد جدول و حذف رکوردهای تکراری با استفاده از CTE
   ============================================================

   📌 این مجموعه کوئری‌ها هدف‌های زیر را دنبال می‌کند:
   ──────────────────────────────────────────────────────────────
   ✅ محاسبه مجموع فروش هر عنوان کتاب و ذخیره در جدول جدید `title_amount`
   ✅ افزودن شناسه یکتا (ID) به جدول با استفاده از ستون `IDENTITY`
   ✅ شناسایی و حذف رکوردهای تکراری بر اساس `title_id` و نگه داشتن فقط رکورد اول از طریق `ROW_NUMBER()`

   🎯 کاربرد اصلی این روش برای پاک‌سازی داده‌ها و حفظ یکتایی رکوردها در شرایطی است که تکرار ناخواسته رخ داده باشد.
*/

-- ایجاد جدول و محاسبه مجموع فروش
SELECT t.title_id, title, SUM(qty * price) AS Amount
INTO title_amount
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title



-- درج مجدد همان داده‌ها (جهت نمایش تکنیک درج مجدد)
INSERT INTO title_amount
SELECT t.title_id, title, SUM(qty * price) AS Amount
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title



-- مشاهده محتویات جدول
SELECT * FROM title_amount



-- افزودن ستون ID یکتا برای مدیریت رکوردها
ALTER TABLE title_amount
ADD Id INT IDENTITY



-- حذف رکوردهای تکراری با نگه داشتن اولین مورد بر اساس ID
;WITH cte AS (
	SELECT Id,
	       ROW_NUMBER() OVER (PARTITION BY title_id ORDER BY Id) AS DelId
	FROM title_amount
)
DELETE title_amount
FROM title_amount
WHERE Id IN (SELECT Id FROM cte WHERE DelId > 1)



/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   ✅ استفاده از `ROW_NUMBER()` با `PARTITION BY` برای شناسایی رکوردهای تکراری راه‌حلی موثر و حرفه‌ای است.
   ✅ استفاده از جدول موقت `title_amount` به کاهش پیچیدگی کوئری‌های تحلیلی کمک می‌کند.
   ⚠️ دقت کنید که افزودن `IDENTITY` بعد از درج داده‌ها ممکن است باعث مشکلاتی در محیط‌های production شود. بهتر است ساختار جدول از ابتدا طراحی شود.
   ─────────────────────────────────────────────
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   5️⃣ مقایسه و اصلاح داده‌ها با استفاده از جدول جدید و JOIN
   ============================================================

   📌 این اسکریپت چند هدف دارد:
   ──────────────────────────────────────────────────────────────
   ✅ ایجاد یک نسخه تصادفی از جدول `jobs` با استفاده از `SELECT INTO` و `NEWID()` به نام `jobs_merge`
   ✅ درج چند رکورد جدید در `jobs_merge`
   ✅ اعمال به‌روزرسانی بر روی فیلد `min_lvl` در شرایط خاص
   ✅ مقایسه محتوای دو جدول `jobs` و `jobs_merge` با استفاده از `FULL JOIN` برای نمایش تفاوت‌ها

   🎯 این روش بسیار مناسب برای تست، شبیه‌سازی داده، و مقایسه دیتاست‌ها در سناریوهای مختلف می‌باشد.
*/

-- حذف جدول در صورت وجود قبلی
DROP TABLE IF EXISTS jobs_merge



-- ساخت جدول جدید با ۱۰ ردیف به صورت تصادفی از جدول jobs
SELECT TOP 10 *
INTO jobs_merge
FROM jobs
ORDER BY NEWID()



-- درج رکوردهای جدید به صورت مستقیم
INSERT INTO jobs_merge VALUES ('Database Administrator', 150, 250), 
							  ('BI Developer', 150, 250)



-- به‌روزرسانی سطح حداقل مهارت برای job_id های کوچکتر از ۵
UPDATE jobs_merge SET min_lvl = min_lvl + 10 
WHERE job_id < 5



-- مقایسه کامل دو جدول jobs و jobs_merge برای نمایش تفاوت‌ها
SELECT * 
FROM jobs 
FULL JOIN jobs_merge ON jobs.job_id = jobs_merge.job_id



/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   ✅ استفاده از `FULL JOIN` ابزاری قدرتمند برای مقایسه جامع بین دو جدول است.
   ✅ توابع `NEWID()` و `TOP` به خوبی برای شبیه‌سازی تست‌های تصادفی عمل می‌کنند.
   ⚠️ توجه داشته باشید که FULL JOIN در دیتاست‌های بزرگ می‌تواند منابع زیادی مصرف کند؛ در صورت نیاز از فیلترهای محدودکننده استفاده کنید.
   ─────────────────────────────────────────────
*/



/* ============================================================
   6️⃣ همگام‌سازی کامل داده‌ها با استفاده از MERGE و IDENTITY_INSERT
   ============================================================

   📌 در این بخش، هدف استفاده از دستور `MERGE` برای تطبیق کامل جدول `jobs_merge` با جدول اصلی `jobs` است.
   ──────────────────────────────────────────────────────────────
   🔧 عملیات مورد استفاده:
   ✅ درج (INSERT) رکوردهای جدیدی که در `jobs` هستند ولی در `jobs_merge` نیستند
   ✅ به‌روزرسانی (UPDATE) رکوردهای موجود بر اساس `job_id`
   ✅ حذف (DELETE) رکوردهایی که در `jobs_merge` وجود دارند ولی در `jobs` نیستند
   ✅ فعال‌سازی دستی `IDENTITY_INSERT` برای امکان درج `job_id` به صورت مستقیم

   ⚙️ خروجی با استفاده از `OUTPUT` نمایش عملیات و مقادیر جدید و قدیمی را فراهم می‌کند.
*/



-- فعال‌سازی درج مستقیم شناسه‌ها برای ستون Identity
SET IDENTITY_INSERT jobs_merge ON 



-- اجرای دستور MERGE جهت همگام‌سازی دقیق جداول
MERGE jobs_merge AS TARGET 
USING jobs AS SOURCE 
ON SOURCE.job_id = TARGET.job_id



-- در صورت نبود در مقصد: درج شود
WHEN NOT MATCHED BY TARGET THEN 
	INSERT (job_id, job_desc, min_lvl, max_lvl)
	VALUES (SOURCE.job_id, SOURCE.job_desc, SOURCE.min_lvl, SOURCE.max_lvl)



-- در صورت تطابق: فقط به‌روزرسانی min_lvl
WHEN MATCHED THEN 
	UPDATE SET min_lvl = SOURCE.min_lvl 



-- در صورت نبود در مبدا: حذف شود
WHEN NOT MATCHED BY SOURCE THEN 
	DELETE



-- خروجی دقیق عملیات
OUTPUT 
	$ACTION, 
	ISNULL(inserted.job_id, deleted.job_id) job_id, 
	ISNULL(inserted.job_desc, deleted.job_desc) job_desc, 
	ISNULL(inserted.min_lvl, deleted.min_lvl) min_lvl, 
	ISNULL(inserted.max_lvl, deleted.max_lvl) max_lvl;



-- غیرفعال‌سازی درج مستقیم پس از اتمام کار
SET IDENTITY_INSERT jobs_merge OFF



/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   ✅ دستور `MERGE` یکی از ابزارهای قدرتمند T-SQL برای همگام‌سازی رکوردها است.
   ✅ استفاده از `OUTPUT` امکان بررسی دقیق عملکرد و تأثیر عملیات را فراهم می‌کند.
   ⚠️ استفاده از `IDENTITY_INSERT` فقط در مواقع خاص ضروری است و در سایر شرایط بهتر است از آن پرهیز شود.
   ─────────────────────────────────────────────
*/

-------------------------------------------------------------------------------------------------------------



/* ============================================================
   7️⃣ مقایسه عملکرد DELETE و TRUNCATE و استفاده مجدد از جدول
   ============================================================

   📌 در این قسمت هدف بررسی روش‌های مختلف حذف و بارگذاری مجدد داده‌ها در جدول `NewJob` است.
   🔄 این روش‌ها شامل استفاده از `DELETE` و `TRUNCATE` برای پاکسازی جدول هستند و سپس داده‌ها از جدول اصلی `jobs` بازیابی می‌شوند.

   🎯 تفاوت کلیدی بین DELETE و TRUNCATE در موارد زیر است:
   ------------------------------------------------------------
   ✅ `DELETE` سطری عمل می‌کند و قابل کنترل و بازگشت‌پذیرتر است (در صورت استفاده از تراکنش)
   ✅ `TRUNCATE` سریع‌تر اجرا می‌شود ولی لاگ کمتری ثبت می‌کند و قابل Rollback نیست
   ✅ پس از `TRUNCATE`، شمارنده Identity نیز ریست می‌شود
*/

-- ایجاد جدول NewJob با کپی از jobs
DROP TABLE IF EXISTS NewJob
SELECT *
INTO NewJob
	FROM jobs



-- حذف داده‌ها با دستور DELETE
DELETE NewJob



-- بارگذاری مجدد داده‌ها با INSERT
INSERT INTO NewJob (job_desc, min_lvl, max_lvl) 
	SELECT job_desc, min_lvl, max_lvl 
	FROM jobs

	

-- نمایش جدول پس از بارگذاری مجدد
SELECT *
	FROM NewJob



-- اجرای مجدد با TRUNCATE
DROP TABLE IF EXISTS NewJob
SELECT *
INTO NewJob
	FROM jobs



-- حذف سریع و کامل داده‌ها بدون لاگ‌گذاری سطری
TRUNCATE TABLE NewJob



-- بارگذاری مجدد داده‌ها
INSERT INTO NewJob (job_desc, min_lvl, max_lvl) 
	SELECT job_desc, min_lvl, max_lvl 
	FROM jobs



-- نمایش نهایی
SELECT *
	FROM NewJob



/* 🔍 نکات بهینه‌سازی (Performance Tips)
   ─────────────────────────────────────────────
   ⚡ برای جداول بزرگ و زمانی که نیازی به لاگ دقیق و Rollback نیست، استفاده از `TRUNCATE` بسیار سریع‌تر از `DELETE` است.
   🔁 اگر جدول دارای وابستگی‌های کلیدی خارجی باشد، امکان اجرای `TRUNCATE` بدون غیرفعالسازی موقت کلیدها وجود ندارد.
   ✅ برای بارگذاری‌های اولیه یا پاکسازی موقت با سرعت بالا، `TRUNCATE` توصیه می‌شود.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   8️⃣ بررسی تفاوت TRUNCATE و DELETE در جداول با کلید خارجی
   ============================================================

   📌 در این بخش قصد داریم تفاوت اجرای `TRUNCATE` و `DELETE` روی جدولی را که جدول دیگر با `FOREIGN KEY` به آن متصل است بررسی کنیم.

   ⚠️ نکته مهم:
   ----------------------------------------
   ❗ دستور `TRUNCATE TABLE` به دلیل بررسی نکردن محدودیت‌های مرجع (`FOREIGN KEY`)
   نمی‌تواند روی جداولی که از آن‌ها به صورت مرجع استفاده شده اجرا شود مگر ابتدا کلید خارجی حذف یا غیرفعال شود.
*/



-- تعریف جدول اصلی با کلید اصلی
CREATE TABLE Ta (
	Id int PRIMARY KEY
)



-- تعریف جدول فرعی با کلید خارجی که به جدول Ta ارجاع می‌دهد
CREATE TABLE Tb (
	Id int,
	Id_A int FOREIGN KEY REFERENCES Ta(Id)
)



-- تلاش برای حذف داده‌ها از جدول مرجع
-- این دستور خطا می‌دهد اگر در جدول Tb داده‌ای ارجاع داده شده باشد
TRUNCATE TABLE Ta  -- ❌ اجرا نخواهد شد در صورت وجود ارجاع



-- دستور جایگزین امن‌تر و مجاز
DELETE FROM Ta  -- ✅ در صورت عدم وجود ارجاع قابل اجراست


/* 🔍 نکات پرفورمنسی و امنیتی
   ─────────────────────────────────────────────
   ✅ `TRUNCATE` سریع‌تر است ولی در صورت وجود محدودیت‌های مرجع قابل استفاده نیست.
   ⚠️ بهتر است هنگام طراحی جداول با روابط وابسته، حذف منطقی (`DELETE`) و بررسی وابستگی‌ها مد نظر قرار گیرد.
   🧩 اگر نیاز به پاکسازی کلی دارید و جدول کلید خارجی ندارد، `TRUNCATE` گزینه مناسب‌تری است.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   9️⃣ تعریف و مقداردهی متغیرها در SQL Server
   ============================================================

   🎯 هدف این بخش، آموزش نحوه تعریف متغیر با استفاده از `DECLARE` و مقداردهی با `SET` یا `SELECT` است.

   💡 در سناریوی حاضر ابتدا یک متغیر عددی تعریف شده و سپس به آن مقدار دهی ثابت و سپس مقداردهی داینامیک از طریق `SELECT COUNT(*)` انجام شده است.
*/

-- تعریف متغیر عدد صحیح
DECLARE @i int



-- مقداردهی اولیه
SET @i = 10 



-- نمایش اولیه در صورت نیاز
-- SELECT @i
-- PRINT @i



-- مقداردهی از طریق کوئری (تعداد رکوردهای جدول titles)
SET @i = (SELECT COUNT(*) FROM titles)



-- نمایش مقدار جدید در صورت نیاز
-- SELECT @i



/* 🔍 نکات تکمیلی
   ──────────────────────────────────────
   ✅ `SET` فقط یک مقدار را می‌پذیرد، در حالی که `SELECT` می‌تواند همزمان چند متغیر را مقداردهی کند.
   🧩 مقداردهی داینامیک به متغیرها کاربرد زیادی در شرط‌ها، حلقه‌ها و کنترل جریان دارد.
*/



-------------------------------------------------------------------------------------------------------------



/*
IF @i > 20
BEGIN 
	SELECT *
		FROM titles
END
ELSE 
BEGIN
	SELECT *
		FROM authors
END
*/



-------------------------------------------------------------------------------------------------------------


/* ============================================================
   🔁 10. استفاده از حلقه WHILE برای تکرار دستورات
   ============================================================

   🎯 در این بخش از دستور `WHILE` برای اجرای مکرر یک بلوک از دستورات استفاده شده است.
   📌 حلقه تا زمانی ادامه پیدا می‌کند که شرط `@i > 0` برقرار باشد.

   👇 این مثال به سادگی از مقدار فعلی متغیر `@i` تا عدد 1 را به ترتیب نزولی چاپ می‌کند.
*/

WHILE @i > 0 
BEGIN 
	PRINT @i
	SET @i -=1
END 

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ✅ `WHILE` ابزاری مفید برای تکرار، مخصوصاً در کارهای اداری، انباشت‌ها و عملیات شرطی تکرارشونده است.
   ⚠️ در صورت استفاده نادرست یا عدم بروزرسانی متغیر کنترلی، می‌تواند منجر به حلقه بی‌نهایت شود.
   💡 استفاده از `PRINT` برای مقادیر کوچک جهت دیباگ مناسب است اما در حلقه‌های سنگین بهتر است از آن اجتناب شود.
*/


-------------------------------------------------------------------------------------------------------------



/* ============================================================
   🧪 11. تبدیل‌ها، توابع پیش‌فرض و بررسی موقعیت کاراکتر
   ============================================================

   🎯 در این بخش چند تابع پایه‌ای و مهم SQL بررسی شده است که شامل:
   - `CAST`: برای تبدیل نوع داده‌ها (مثلاً از float به int)
   - `ISNULL`: برای جایگزینی مقدار NULL با یک مقدار مشخص
   - `ASCII` و `CHAR`: تبدیل بین کاراکتر و کد ASCII آن
   - `CHARINDEX`: پیدا کردن موقعیت یک کاراکتر در رشته

   🧠 این توابع بسیار کاربردی هستند و در عملیات روزمره SQL به کرات استفاده می‌شوند.
*/

SELECT CAST(1.258 AS int), ISNULL(1 , 0), ISNULL(NULL , 1)

SELECT title_id, title, price, ISNULL(price , 0)
FROM titles

SELECT ASCII('a'), CHAR(97)

SELECT CHARINDEX('_', 'Test_App')

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ✅ `CAST` نسبت به `CONVERT` ساده‌تر است و برای تبدیل مستقیم مفید است.
   ✅ `ISNULL` برای جلوگیری از خطاهای محاسباتی و گزارش‌دهی دقیق‌تر مفید است.
   🔠 `CHARINDEX` بسیار سریع است و در توابع رشته‌ای یا تحلیل کدها کاربرد دارد.
   🛠️ ترکیب این توابع می‌تواند در ساخت گزارش‌ها و قالب‌بندی رشته‌ها بسیار موثر باشد.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   🔍 12. کار با توابع رشته‌ای برای تجزیه و تحلیل اطلاعات متنی
   ============================================================

   🎯 در این بخش به نحوه استفاده از توابع `CHARINDEX`, `LEFT`, `SUBSTRING`, `RIGHT`, و `CONCAT` در SQL پرداخته شده است.
   - استخراج اجزای `au_id` با استفاده از موقعیت `-` در رشته
   - قالب‌بندی یک تاریخ به صورت سفارشی
   - تقسیم رشته به بخش‌های مختلف جهت پردازش ساختارهای خاص مانند کدهای ملی یا تاریخ

   🛠️ این مهارت‌ها برای آماده‌سازی داده‌ها در گزارش‌گیری و ساختن نمای ظاهری بهتر اطلاعات ضروری هستند.
*/

-- استخراج موقعیت خط تیره‌ها در کد نویسنده
SELECT au_id, au_lname, 
       CHARINDEX('-', au_id), 
       CHARINDEX('-', au_id, CHARINDEX('-', au_id) + 1)
FROM authors

-- تبدیل تاریخ به اجزای سال، ماه و روز
SELECT LEFT('14021104', 4), 
       SUBSTRING('14021104', 5, 2), 
       RIGHT('14021104', 2)

-- ترکیب سال، ماه و روز به فرمت تاریخ متنی
SELECT CONCAT(LEFT('14021104', 4), '/', SUBSTRING('14021104', 5, 2), '/', RIGHT('14021104', 2))

-- تجزیه کد نویسنده به سه بخش با استفاده از توابع رشته‌ای
SELECT au_id, au_lname,
       LEFT(au_id, CHARINDEX('-', au_id) - 1),
       SUBSTRING(au_id, CHARINDEX('-', au_id) + 1, CHARINDEX('-', au_id, CHARINDEX('-', au_id) + 1) - CHARINDEX('-', au_id) - 1),
       SUBSTRING(au_id, CHARINDEX('-', au_id, CHARINDEX('-', au_id) + 1) + 1, 15)
FROM authors

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ⚙️ استفاده زیاد از `CHARINDEX` و `SUBSTRING` ممکن است روی خوانایی تأثیر بگذارد، اما در مواقع ضروری بسیار مفید است.
   📌 در شرایط پیچیده‌تر بهتر است از توابع `SPLIT`, `STRING_SPLIT`, یا UDF استفاده شود.
   ✅ توابع متنی برای پردازش IDها، تاریخ‌ها، و کدهای ساختاریافته بسیار کلیدی‌اند.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   🔢 13. بررسی طول رشته و قالب‌بندی عددی در SQL Server
   ============================================================

   🎯 در این بخش با توابع `LEN`, `DATALENGTH`, `REPLACE`, `CAST`, و `FORMAT` آشنا می‌شویم.
   - اندازه‌گیری طول منطقی و بایت یک رشته
   - حذف کاراکتر خاص از یک رشته و تبدیل به عدد
   - قالب‌بندی اعداد برای نمایش بهتر و خواناتر

   📌 این تکنیک‌ها در آماده‌سازی داده برای نمایش نهایی، گزارش‌گیری یا ذخیره‌سازی استاندارد بسیار کاربردی هستند.
*/

-- بررسی طول منطقی (کاراکتر) و بایت (دیتا) رشته‌ها
SELECT title_id, title, LEN(title), type, DATALENGTH(type)
FROM titles

-- حذف خط تیره‌ها از au_id و تبدیل به عدد صحیح
SELECT au_id, CAST(REPLACE(au_id, '-', '') AS int), au_fname 
FROM authors

-- قالب‌بندی عدد به صورت گروه‌بندی‌شده (فرمت اعداد)
SELECT FORMAT(CAST(REPLACE(au_id, '-', '') AS int), '##,##') 
FROM authors

-- فرمت عدد بزرگ همراه با واحد پولی
SELECT FORMAT(321323213215465, '##,## ريال')

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ✅ `LEN` طول کاراکتری و `DATALENGTH` طول بایتی را می‌سنجد که برای داده‌های Unicode تفاوت مهمی دارد.
   ⚠️ تبدیل رشته به عدد با `REPLACE` و `CAST` نیاز به کنترل خطا دارد در صورتی که داده‌ها فرمت ناسازگار داشته باشند.
   💡 استفاده از `FORMAT` برای نمایش نهایی داده‌ها مناسب است اما در پردازش‌های حجیم ممکن است پرفورمنس را کاهش دهد.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   📅 14. توابع تاریخ و ریاضی در SQL Server
   ============================================================

   🎯 در این بخش با توابع مختلف کار با تاریخ و توابع ریاضی آشنا می‌شویم:
   - `GETDATE()` برای گرفتن تاریخ و زمان فعلی
   - `FORMAT()` برای قالب‌بندی تاریخ مطابق فرهنگ (مثلاً فارسی)
   - `ROUND()` برای گرد کردن اعداد
   - `PI()` برای عدد پی
   - `DATEDIFF()` برای محاسبه فاصله زمانی
   - `DATEADD()` برای افزودن به تاریخ
   - `DATEPART()` برای استخراج بخش خاصی از تاریخ

   📌 این توابع کاربرد فراوانی در محاسبات زمانی، نمایش تاریخ‌ها و کارهای تحلیلی دارند.
*/

-- گرفتن تاریخ جاری، قالب فارسی و فشرده
SELECT GETDATE(), FORMAT(GETDATE(), 'yyyy/MM/dd', 'fa-IR'), FORMAT(GETDATE(), 'yyyyMMdd', 'fa-IR')

-- گرد کردن عدد به نزدیک‌ترین عدد صحیح
SELECT ROUND(32132.2, 0, 0)

-- مقدار عدد پی
SELECT PI()

-- فاصله روزی از تاریخ مشخص تا امروز
SELECT DATEDIFF(DAY, '2023-12-05', GETDATE())

-- افزودن 30 روز به تاریخ فعلی
SELECT DATEADD(DAY, 30, GETDATE())

-- استخراج ساعت از تاریخ فعلی
SELECT DATEPART(HOUR, GETDATE())

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ✅ استفاده از `FORMAT()` بیشتر برای نمایشی است، در پردازش‌های زیاد ممکن است کند باشد.
   ⚠️ `DATEDIFF()` در سنجش اختلاف حساس است به ترتیب پارامترها.
   ✅ `DATEADD()` و `DATEPART()` بسیار کاربردی در تحلیل‌های زمانی هستند.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   🧮 15. استفاده از CAST، CONVERT و توابع رشته‌ای در SQL
   ============================================================

   🎯 این بخش شامل نمونه‌هایی از تبدیل داده‌ها و کار با رشته‌هاست:
   - `CONVERT(int, float)` برای تبدیل عدد اعشاری به عدد صحیح
   - `CONVERT(varchar, date, style)` برای تبدیل تاریخ به رشته فرمت‌شده با سبک خاص
   - `STRING_SPLIT()` برای جدا کردن رشته با جداکننده مشخص (مثلاً -)

   📌 این توابع در پردازش داده، نمایش تاریخ‌ها، و تحلیل رشته‌ای کاربرد زیادی دارند.
*/

-- تبدیل عدد اعشاری به عدد صحیح
SELECT CONVERT(int , 1458.32154646)

-- تبدیل تاریخ جاری به رشته با فرمت هجری شمسی (style 130)
SELECT CONVERT(varchar, GETDATE() , 130)

-- تبدیل رشته به لیست با استفاده از جداکننده خط تیره
SELECT *
	FROM string_split('998-72-3567' , '-')

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ✅ `CONVERT()` مناسب برای تبدیل دقیق نوع داده‌ها بین رشته، تاریخ، عدد و ...
   ⚠️ استفاده از styleهای خاص (مثلاً 130) می‌تواند کند باشد در حجم زیاد
   ✅ `STRING_SPLIT()` در SQL Server 2016 به بعد موجود است و برای شکستن رشته‌ها بسیار سریع و کارآمد است.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   🧾 16. استفاده از STRING_AGG برای نمایش لیست نویسندگان
   ============================================================

   🎯 این کوئری با استفاده از تابع `STRING_AGG` اسامی نویسندگان هر کتاب را در یک رشته جدا شده با `,` تجمیع می‌کند.
   - ترکیب `au_fname + ' ' + au_lname` برای نمایش نام کامل نویسنده
   - گروه‌بندی بر اساس `title_id` و `title` برای هر کتاب

   📌 این روش برای ساخت گزارش‌های متنی یا فهرست‌سازی نویسندگان در یک ستون بسیار مناسب است.
*/

SELECT  t.title_id, title, STRING_AGG(au_fname + ' ' + au_lname, ' , ')
	FROM titles t
	INNER JOIN titleauthor l ON l.title_id = t.title_id
	INNER JOIN authors a ON a.au_id = l.au_id
	GROUP BY t.title_id, title
GO

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ✅ `STRING_AGG()` تابعی جدیدتر از SQL Server 2017 است و بسیار بهینه برای تجمیع رشته‌ای.
   ✅ حذف نیاز به توابع پیچیده `STUFF` و `FOR XML PATH` برای تجمیع متنی.
   ⚠️ در دیتاست‌های بزرگ، بهتر است ایندکس‌ها روی `title_id` و `au_id` بررسی شود.
*/



-------------------------------------------------------------------------------------------------------------



/* ============================================================
   🧾 17. ساخت تابع اسکالر برای محاسبه مبلغ فروش هر کتاب
   ============================================================

   🎯 این تابع اسکالر (Scalar-Valued Function) با نام `svfAmount` برای محاسبه مجموع مبلغ فروش (تعداد × قیمت) هر کتاب طراحی شده است.
   📥 پارامتر ورودی تابع: `@title_id` به عنوان کلید شناسایی کتاب
   📤 خروجی تابع: مقدار پولی از نوع `money`

   📌 در ادامه، تابع برای تمام کتاب‌های جدول `titles` فراخوانی شده است تا مبلغ فروش هرکدام را نشان دهد.
*/

CREATE FUNCTION svfAmount (@title_id varchar(6))
RETURNS money
AS
BEGIN 
	DECLARE @Result money = (
		SELECT SUM(qty * price)
		FROM titles t
		INNER JOIN sales s ON s.title_id = t.title_id
		WHERE t.title_id = @title_id
	)
	RETURN @Result
END 
GO

SELECT title_id, title, dbo.svfAmount(title_id)
	FROM titles
GO

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ⚠️ توابع اسکالر در SQL Server به صورت row-by-row اجرا می‌شوند و می‌توانند در دیتاست‌های بزرگ عملکرد ضعیفی داشته باشند.
   ✅ در صورت امکان، محاسبه کلی با JOIN و GROUP BY جایگزین شود تا کارایی افزایش یابد.
   ✅ مناسب برای منطق‌هایی است که باید به صورت جداگانه و خاص برای هر ردیف اعمال شوند.
*/



-------------------------------------------------------------------------------------------------------------




/* ============================================================
   📚 18. تابع اسکالر برای شمارش نویسندگان هر کتاب
   ============================================================

   🎯 این تابع با نام `svfTitleAuCo` تعداد نویسندگان هر کتاب را از جدول `titleauthor` بازمی‌گرداند.
   📥 پارامتر ورودی: `@title_id` به عنوان شناسه کتاب
   📤 خروجی: تعداد نویسندگان از نوع `tinyint`

   📌 سپس در کوئری دوم، این تابع برای هر کتاب از جدول `titles` فراخوانی شده و همراه با مجموع فروش (`svfAmount`) نمایش داده می‌شود.
*/

CREATE FUNCTION svfTitleAuCo (@title_id varchar(6))
RETURNS tinyint
AS
BEGIN 
	RETURN (
		SELECT COUNT(*)
		FROM titleauthor
		WHERE title_id = @title_id
	)
END 
GO

SELECT title_id, title, dbo.svfTitleAuCo(title_id), dbo.svfAmount(title_id)
	FROM titles
GO

/* 🔍 نکات پرفورمنسی و سینتکسی
   ──────────────────────────────────────
   ⚠️ مشابه تابع قبلی، این تابع نیز به‌صورت row-by-row اجرا می‌شود و در دیتاست‌های بزرگ باعث کاهش سرعت می‌گردد.
   ✅ اگر تنها نیاز به گزارش کلی دارید، از JOIN و GROUP BY استفاده کنید.
   ✅ مناسب برای گزارش‌های موردی و نیاز به فراخوانی تابع در یک ستون مجزا.
*/
