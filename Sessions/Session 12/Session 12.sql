

/*
    ==========================================================
    جلسه ۱۲: توابع پنجره‌ای (Window Functions) و کاربردهای پیشرفته
    ==========================================================

    در این جلسه، با توابع پنجره‌ای (Window Functions) در SQL Server آشنا می‌شویم.
    این توابع ابزار قدرتمندی برای انجام محاسبات ردیف‌به‌ردیف روی مجموعه‌ای از داده‌ها هستند، بدون اینکه آن‌ها را گروه‌بندی کنند.

    همچنین مفاهیم مقایسه‌ای بین روش‌های سنتی و مدرن مانند `ROW_NUMBER()` و `RANK()` بررسی می‌شوند.

    📌 مباحث مهم این جلسه:
    --------------------------------------
    1. استفاده از تابع `ROW_NUMBER()` برای شماره‌گذاری ردیف‌ها
    2. توابع `RANK()`, `DENSE_RANK()` و `NTILE()` برای رتبه‌بندی داده‌ها
    3. تحلیل‌های پیشرفته با `OVER (PARTITION BY ...)`
    4. تابع `LAG()` و `LEAD()` برای دسترسی به مقادیر قبلی یا بعدی
    5. مقایسه مقادیر سال‌های مختلف با استفاده از `LAG`
    6. محاسبات تجمعی مانند `SUM(...) OVER (...)` و `AVG(...) OVER (...)`
    7. تعریف محدوده‌های دلخواه با `ROWS BETWEEN`
    8. ساختارهای جدید Window Definitions (مانند `WINDOW w AS (...)`)
    9. استفاده از `SEQUENCE` برای تولید شناسه‌های ترتیبی

    مثال‌ها در این جلسه از دیتابیس‌های `pubs` و `AdventureWorks2022` استفاده می‌کنند.

    ==========================================================
*/



USE pubs
GO 

/* ============================================================
   1. 🎯 مقایسه بین روش سنتی و توابع پنجره‌ای برای شماره‌گذاری ردیف‌ها
   ============================================================

   🔍 کوئری اول با استفاده از یک ساب‌کوئری (زیرپرس و شرطی) شماره ردیف‌ها را مشخص می‌کند.
   ❗ این روش سنتی‌تر و سنگین‌تر است و به ازای هر ردیف یک کوئری داخلی اجرا می‌شود.
*/

SELECT 
    (SELECT COUNT(*) 
     FROM authors a 
     WHERE a.au_id <= r.au_id) AS RowNum,
    au_id, 
    au_fname,
    au_lname
FROM authors r
ORDER BY au_id;

-- ⚠️ این روش برای دیتاست‌های بزرگ کارایی پایین‌تری دارد زیرا از ساب‌کوئری برای هر ردیف استفاده می‌کند.



/* ============================================================
   2. 🚀 استفاده از تابع پنجره‌ای ROW_NUMBER برای شماره‌گذاری ردیف‌ها
   ============================================================

   🧠 این روش با استفاده از تابع `ROW_NUMBER()` هر ردیف را بر اساس ترتیب `au_id` شماره‌گذاری می‌کند.
   ✅ بسیار سریع‌تر و بهینه‌تر نسبت به روش سنتی.
*/

SELECT 
    ROW_NUMBER() OVER (ORDER BY au_id) AS RowNum,
    au_id, 
    au_fname, 
    au_lname
FROM authors;

-- 🔥 این روش پیشنهاد می‌شود چون از قابلیت‌های بهینه موتور SQL استفاده می‌کند.
-- 📈 عملکرد بهتر، خوانایی بیشتر، مناسب برای تحلیل‌های ردیف‌به‌ردیف.


	----------------------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------------------




	/*

	https://learn.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver16
		RANK 
		Agg 
	*/




	----------------------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------------------



USE T_AdventureWorks2022



---------------------------------------------------------------------------



/* ============================================================
   3. 📊 محاسبه مجموع تجمعی SubTotal در هر روز سفارش
   ============================================================

   🎯 این کوئری از تابع پنجره‌ای `SUM()` همراه با `OVER` برای محاسبه مجموع تجمعی (Running Total) استفاده می‌کند.
   🗂️ `PARTITION BY OrderDate` به این معنی است که مجموع برای هر روز جداگانه محاسبه می‌شود.
   📌 `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` باعث می‌شود که مجموع از اولین ردیف تا ردیف فعلی در همان پارتیشن لحاظ شود.
   🎨 از `FORMAT` برای زیباتر کردن نمایش عددی استفاده شده است.
*/

SELECT 
    SalesOrderID, 
    OrderDate, 
    SubTotal, 
    FORMAT(
        SUM(SubTotal) OVER (
            PARTITION BY OrderDate 
            ORDER BY SalesOrderID 
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ), 
        '###,###'
    ) AS RunningTotal
FROM Sales.SalesOrderHeader;

-- 📈 کاربردی در گزارش‌گیری مالی و تحلیلی برای بررسی روند فروش هر روز.
-- 🧠 این روش باعث بهبود خوانایی و تفکیک درست محاسبات در بازه‌های زمانی می‌شود.


---------------------------------------------------------------------------



USE T_pubs



---------------------------------------------------------------------------



/* ============================================================
   4. 🏷️ پیدا کردن پنجمین کتاب گران‌قیمت با استفاده از Subquery
   ============================================================

   🎯 در این کوئری ابتدا با `SELECT TOP 5 ... ORDER BY price DESC` پنج کتاب گران‌قیمت انتخاب می‌شود.
   🔽 سپس با `MIN(price)` از بین آن پنج مورد، کمترین قیمت انتخاب می‌شود که در واقع پنجمین قیمت است.
*/

SELECT * 
FROM titles 
WHERE price = (
    SELECT MIN(price)
    FROM (
        SELECT DISTINCT TOP 5 price
        FROM titles
        ORDER BY price DESC
    ) AS D
);

-- ⚠️ این روش ساده و موثر است اما قابل توسعه برای موارد پیچیده‌تر نیست.
-- 📉 ممکن است در دیتاست‌های بزرگتر به دلیل Subquery پرفورمنس بهینه نداشته باشد.



/* ============================================================
   5. 🥇 پیدا کردن پنجمین کتاب گران‌قیمت با استفاده از تابع RANK()
   ============================================================

   🎯 در این روش از تابع `RANK()` برای مرتب‌سازی بر اساس قیمت نزولی استفاده شده است.
   🧮 سپس رکوردی که `RankPrice = 5` دارد، یعنی پنجمین کتاب گران‌قیمت، فیلتر می‌شود.
*/

;WITH cte AS (
    SELECT title_id, title, price, 
           RANK() OVER (ORDER BY price DESC) AS RankPrice
    FROM titles
)
SELECT * 
FROM cte 
WHERE RankPrice = 5;

-- ✅ این روش مدرن‌تر، قابل توسعه و دقیق‌تر از Subquery است.
-- 🚀 از نظر پرفورمنس هم در بسیاری از سناریوها بهتر از Subquery عمل می‌کند.



/* ============================================================
   6. 📈 مقایسه فروش سالیانه با سال قبل (روش JOIN خودمرجع)
   ============================================================

   🎯 ابتدا مجموع فروش (Amount) برای هر سال محاسبه می‌شود.
   🔄 سپس با استفاده از یک `LEFT JOIN` روی همان CTE، مقدار فروش همان سال با سال قبل مقایسه می‌شود.
*/

WITH cte AS (
    SELECT YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
    FROM titles s 
    INNER JOIN sales t ON t.title_id = s.title_id
    GROUP BY YEAR(ord_date)
)

SELECT 
    c.Year, 
    c.Amount, 
    b.Amount AS PerAmount
FROM cte c
LEFT JOIN cte b ON c.Year = b.Year + 1;

-- 🧠 مناسب برای تحلیل تغییرات سالانه در فروش.
-- 📌 در دیتاست‌هایی با تعداد رکورد کم تا متوسط، این ساختار ساده و سریع است.



-----------------------------------------------------------------



/* ============================================================
   7. ⏪ بررسی تغییرات فروش سالیانه با تابع LAG
   ============================================================

   🎯 این کوئری ابتدا مجموع فروش سالانه (Amount) را محاسبه می‌کند.
   🕓 سپس با استفاده از تابع `LAG()`، مقدار فروش سال قبل نیز در کنار هر رکورد نمایش داده می‌شود.
*/

;WITH cte AS (
    SELECT YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
    FROM titles s 
    INNER JOIN sales t ON t.title_id = s.title_id
    GROUP BY YEAR(ord_date)
)

SELECT *, 
       LAG(Amount, 1) OVER (ORDER BY Year) AS PrevYearAmount
FROM cte;

-- ⛓ تابع LAG به شکل بسیار مؤثری امکان دسترسی به مقدار ردیف قبلی را بدون نیاز به JOIN می‌دهد.
-- 🚀 پرفورمنس بهتر نسبت به JOIN خودمرجع دارد، به‌خصوص در دیتاست‌های بزرگ.
-- 📊 این روش برای تحلیل روندها و مقایسه‌های دوره‌ای ایده‌آل است.



----------------------------------------------------------------------



/* ============================================================
   8. 🏷 مقایسه فروش ناشرها در سال‌های مختلف با تابع LAG
   ============================================================

   🎯 این کوئری مجموع فروش سالیانه را برای هر ناشر محاسبه می‌کند.
   📊 سپس با استفاده از تابع `LAG()`، فروش سال قبل همان ناشر نیز در کنار رکورد نمایش داده می‌شود.
   📁 داده‌ها بر اساس `pub_id` پارتیشن‌بندی و بر اساس سال مرتب‌سازی شده‌اند.
*/

;WITH cte AS (
    SELECT p.pub_id, pub_name, YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
    FROM titles t
    INNER JOIN sales s ON s.title_id = t.title_id
    INNER JOIN publishers p ON p.pub_id = t.pub_id
    GROUP BY p.pub_id, pub_name, YEAR(ord_date)
)

SELECT *, 
       LAG(Amount, 1, 0) OVER (PARTITION BY pub_id ORDER BY Year) AS PrevYearAmount
FROM cte;

-- 🔁 تابع LAG با مقدار پیش‌فرض 0 در صورت نبود رکورد قبلی، از خطای NULL جلوگیری می‌کند.
-- 🧠 این ساختار در تحلیل‌های مقایسه‌ای بین سال‌ها برای هر ناشر مفید است.
-- 🚀 بهینه‌تر از JOINهای تودرتو برای بازیابی اطلاعات ردیف قبلی است.



--------------------------------------------------------



/* ============================================================
   9. 📊 تحلیل روند فروش بر اساس نوع کتاب با تابع LAG
   ============================================================

   🎯 این کوئری مجموع فروش را به تفکیک نوع کتاب (`type`) و سال محاسبه می‌کند.
   🕓 سپس با استفاده از تابع `LAG()`، مقدار فروش سال قبل برای همان نوع کتاب محاسبه و در کنار مقدار فعلی نمایش داده می‌شود.
   🗂 داده‌ها به کمک `PARTITION BY type` گروه‌بندی و بر اساس `Year` مرتب‌سازی شده‌اند.
*/

;WITH cte AS (
    SELECT type, YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
    FROM titles s
    INNER JOIN sales t ON t.title_id = s.title_id
    GROUP BY YEAR(ord_date), type
)

SELECT *, 
       LAG(Amount, 1) OVER (PARTITION BY type ORDER BY Year) AS PrevYearAmount
FROM cte;

-- 🔍 تحلیل روند فروش هر نوع کتاب در گذر زمان را آسان می‌کند.
-- ✅ استفاده از LAG باعث صرفه‌جویی در زمان اجرا نسبت به JOINهای خودارجاعی می‌شود.
-- 📈 مناسب برای نمایش تغییرات سالانه و تشخیص رشد یا افت فروش.



--------------------------------------------------------



USE AdventureWorks2022



--------------------------------------------------------



/* ============================================================
   10. 📅 تحلیل روزانه فروش با توابع تحلیلی پیشرفته
   ============================================================

   🎯 این کوئری اطلاعات فروش را به تفکیک تاریخ سفارش از جدول `SalesOrderHeader` جمع‌آوری می‌کند.
   📌 سپس با استفاده از توابع تحلیلی مختلف:
        - `LAG()` مقدار فروش روز قبل
        - `LEAD()` مقدار فروش روز بعد
        - `AVG(...) OVER (...)` میانگین سه روزه فروش (روز قبل، روز جاری، روز بعد)
   را برای هر روز محاسبه می‌کند.
   🎨 تمامی مقادیر با `FORMAT()` برای خوانایی بهتر فرمت شده‌اند.
*/

;WITH cte AS (
    SELECT OrderDate, SUM(SubTotal) AS Amount
    FROM Sales.SalesOrderHeader
    GROUP BY OrderDate
)

SELECT 
    OrderDate, 
    FORMAT(LAG(Amount, 1, 0) OVER (ORDER BY OrderDate), '##,##') AS PerDay,
    FORMAT(Amount, '###,###') AS Amount,
    FORMAT(LEAD(Amount, 1, 0) OVER (ORDER BY OrderDate), '##,##') AS NextDay,
    FORMAT(AVG(Amount) OVER (ORDER BY OrderDate ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING), '##,##') AS Avg3Days
FROM cte;

-- 🧠 این ترکیب از توابع تحلیلی، ابزار قدرتمندی برای بررسی تغییرات فروش روزانه فراهم می‌کند.
-- ⚙️ بهینه برای داشبوردهای مدیریتی و گزارش‌های تحلیلی دقیق.



--------------------------------------------------------



USE pubs



--------------------------------------------------------



/* ============================================================
   11. 🔢 استفاده از Sequence برای تولید مقادیر عددی متوالی
   ============================================================

   🎯 این بخش نحوه‌ی ایجاد و استفاده از یک `SEQUENCE` در SQL Server را نشان می‌دهد.
   📌 `SEQUENCE` یک آبجکت مستقل است که می‌تواند مقادیر عددی متوالی (مثلاً برای شناسه‌ها) تولید کند.
*/

CREATE SEQUENCE CountBy1  
    START WITH 1  
    INCREMENT BY 1;

-- استفاده از SEQUENCE برای گرفتن مقدار بعدی
SELECT NEXT VALUE FOR CountBy1;

-- 🧩 گزینه‌ای مناسب برای مواقعی که نیاز به تولید مقادیر یکتا و متوالی خارج از ساختار جدول دارید.
-- ⚠️ برخلاف IDENTITY که به یک ستون خاص وابسته است، SEQUENCE مستقل از جدول عمل می‌کند.



--------------------------------------------------------



USE AdventureWorks2022



--------------------------------------------------------



/* ============================================================
   12. 🏷️ رتبه‌بندی محصولات بر اساس قیمت (ListPrice)
   ============================================================

   🎯 در این کوئری، از تابع `RANK()` استفاده شده تا محصولات بر اساس قیمت‌شان رتبه‌بندی شوند.
   📌 سه رتبه‌بندی متفاوت انجام شده:
   
   - کل محصولات (`ORDER BY ListPrice DESC`)
   - درون هر زیرگروه محصول (`PARTITION BY ProductSubcategoryID`)
   - درون هر گروه اصلی محصول (`PARTITION BY ProductCategoryID`)
*/

SELECT 
	ProductID, 
	p.Name, 
	c.Name, 
	s.Name, 
	ListPrice, 
	RANK() OVER (ORDER BY ListPrice DESC) AS RanKProduct, 
	RANK() OVER (PARTITION BY s.ProductSubcategoryID ORDER BY ListPrice DESC) AS RanKSubcategory, 
	RANK() OVER (PARTITION BY c.ProductCategoryID ORDER BY ListPrice DESC) AS RanKCategory
FROM Production.Product p
INNER JOIN Production.ProductSubcategory s ON s.ProductSubcategoryID = p.ProductSubcategoryID
INNER JOIN Production.ProductCategory c ON c.ProductCategoryID = s.ProductCategoryID;

-- 📊 مناسب برای مقایسه قیمت‌ها در سطوح مختلف دسته‌بندی محصول.
-- ⚠️ در صورت وجود قیمت‌های مساوی، شماره رتبه‌ها ممکن است غیرپیوسته باشند (ویژگی تابع RANK).



-----------------------------------------------------------------------------------



ALTER DATABASE AdventureWorks2022 
	SET COMPATIBILITY_LEVEL = 160



-----------------------------------------------------------------------------------



/* ============================================================
   13. 🪟 استفاده از WINDOW برای بهینه‌سازی و خوانایی کوئری‌های RANK
   ============================================================

   🎯 این کوئری همانند قبلی است اما از ویژگی جدید `WINDOW` استفاده می‌کند که در نسخه‌های جدید SQL Server در دسترس است.
   📦 با تعریف پنجره‌های مختلف یک‌بار و استفاده مجدد از آن‌ها در چندین محاسبه، کد تمیزتر و خواناتر می‌شود.

   📌 تعریف سه پنجره:
   - `w`: بر اساس ListPrice نزولی
   - `ws`: بر اساس `ProductSubcategoryID`
   - `wc`: بر اساس `ProductCategoryID`
*/

SELECT 
	ProductID, 
	p.Name, 
	c.Name, 
	s.Name, 
	ListPrice, 
	RANK() OVER w AS RanKProduct, 
	RANK() OVER ws AS RanKSubcategory, 
	RANK() OVER wc AS RanKCategory
FROM Production.Product p
INNER JOIN Production.ProductSubcategory s ON s.ProductSubcategoryID = p.ProductSubcategoryID
INNER JOIN Production.ProductCategory c ON c.ProductCategoryID = s.ProductCategoryID
WINDOW 
	w AS (ORDER BY ListPrice DESC), 
	ws AS (w PARTITION BY s.ProductSubcategoryID), 
	wc AS (w PARTITION BY c.ProductCategoryID);

-- 🧠 با استفاده از `WINDOW` عملکرد کوئری بهبود نمی‌یابد، اما نگهداری و توسعه آن آسان‌تر می‌شود.
-- ✅ به‌خصوص در کوئری‌های طولانی با محاسبات مکرر مفید است.



/* ============================================================
   14. 🎯 استفاده از چند RANK با پنجره‌های متفاوت در یک کوئری
   ============================================================

   🧩 این کوئری سه رتبه‌بندی مختلف را هم‌زمان روی محصولات اعمال می‌کند:
   - `RanKProduct`: رتبه کلی بر اساس قیمت نزولی
   - `RanKSubcategory`: رتبه درون هر زیرشاخه
   - `RanKCategory`: رتبه درون هر دسته اصلی

   🛠️ پنجره‌ها فقط یک بار تعریف شده‌اند و چند بار استفاده شده‌اند تا تکرار کاهش یابد.
*/

SELECT 
	ProductID, 
	p.Name, 
	c.Name, 
	s.Name, 
	ListPrice, 
	RANK() OVER w AS RanKProduct, 
	RANK() OVER ws AS RanKSubcategory, 
	RANK() OVER wc AS RanKCategory
FROM Production.Product p
INNER JOIN Production.ProductSubcategory s ON s.ProductSubcategoryID = p.ProductSubcategoryID
INNER JOIN Production.ProductCategory c ON c.ProductCategoryID = s.ProductCategoryID
WINDOW 
	w  AS (ORDER BY ListPrice DESC), 
	ws AS (w PARTITION BY s.ProductSubcategoryID), 
	wc AS (w PARTITION BY c.ProductCategoryID);

-- ✅ با این روش می‌توان در یک کوئری چندین نوع رتبه‌بندی را هم‌زمان و با خوانایی بالا انجام داد.
-- 📈 برای ساخت گزارش‌های تحلیلی روی سطوح مختلف دسته‌بندی محصولات کاربردی است.



-------------------------------------------------------------------------------



USE pubs
GO



-------------------------------------------------------------------------------



/*

	DML: 
			1. INSERT 
			2. UPDATE
			3. DELETE
			4. MERGE

INSERT INTO TableName
OUTPUT inserted.*
	VALUES (Expr1 , Expr2 , ... )

INSERT INTO TableName (Field1 , Field2 , .. )
OUTPUT inserted.*
VALUES (Expr1 , Expr2 , ... )

INSERT INTO TableName
OUTPUT inserted.*
	SELECT ....

INSERT INTO TableName (Field1 , Field2 , .. )
OUTPUT inserted.*
	SELECT ....


SELECT ..... 
	INTO NewTable
FROM ....

*/



-------------------------------------------------------------------------------



/* 
===========================================
📚 بخش دوم جلسه دوازدهم: عملیات DML و مدیریت داده‌ها
===========================================

در این بخش از جلسه، به بررسی و تمرین عملیات اصلی DML (Data Manipulation Language) در SQL می‌پردازیم، شامل:

1. **INSERT**: افزودن رکوردهای جدید به جداول با استفاده از روش‌های مختلف:
   - درج مستقیم مقادیر ثابت.
   - درج با استفاده از SELECT از جداول دیگر.
   - استفاده از OUTPUT برای مشاهده رکوردهای درج‌شده.
   - مدیریت مقادیر خودافزایشی (IDENTITY) با توابع @@IDENTITY، SCOPE_IDENTITY() و IDENT_CURRENT().
   - استفاده از SET IDENTITY_INSERT برای درج مقادیر خاص در ستون‌های IDENTITY.

2. **SELECT INTO**: ایجاد جداول جدید و درج داده‌ها به‌صورت همزمان با استفاده از SELECT INTO.

3. **CTE (Common Table Expressions)**: استفاده از CTE برای ساختاردهی بهتر کوئری‌ها و درج داده‌ها به جداول دیگر.

در این بخش، تمرکز بر روی درک عمیق‌تر عملیات درج داده‌ها، مدیریت مقادیر خودافزایشی و استفاده از تکنیک‌های پیشرفته‌تر برای کار با داده‌ها است.
*/



-------------------------------------------------------------------------------



/* ============================================================
   1. 🔍 نمایش و بررسی ساختار جدول jobs
   ============================================================ */

SELECT * 
FROM jobs;

-- نمایش تمام رکوردهای جدول jobs

EXECUTE sp_help 'jobs';

-- نمایش ساختار کامل جدول jobs شامل ستون‌ها، نوع داده‌ها، و محدودیت‌ها


/* ============================================================
   2. 🧾 درج رکوردهای جدید در جدول jobs به شیوه‌های مختلف
   ============================================================ */

-- درج ساده یک رکورد بدون تعیین نام ستون‌ها (ترتیب باید مطابق ساختار جدول باشد)
INSERT INTO jobs 
VALUES ('Test_01', 100, 200);

-- درج رکورد با تعیین نام ستون‌ها (خواناتر و امن‌تر)
INSERT INTO jobs (job_desc, min_lvl, max_lvl) 
VALUES ('Test_02', 100, 200);

-- درج رکورد با ترتیب متفاوت ستون‌ها
INSERT INTO jobs (min_lvl, job_desc, max_lvl) 
VALUES (100, 'Test_03', 200);

-- درج چند رکورد به صورت همزمان (Bulk Insert)
INSERT INTO jobs 
VALUES ('Test_04', 100, 200),
       ('Test_05', 100, 200),
       ('Test_06', 100, 200),
       ('Test_07', 100, 200);

-- 📝 نکته پرفورمنسی: استفاده از Insert چندگانه در یک دستور می‌تواند سریع‌تر از اجرای چندین Insert تکی باشد، مخصوصاً در حجم داده‌ی بالا.
-- 🛡️ توصیه می‌شود همیشه نام ستون‌ها را به صورت مشخص ذکر کنید تا در صورت تغییر ساختار جدول، کوئری‌ها دچار خطا نشوند.



/* ============================================================
   3. 🆔 بررسی روش‌های مختلف دریافت آخرین شناسه درج شده (Identity)
   ============================================================ */

-- درج رکورد و سپس دریافت بالاترین job_id از جدول (روش عمومی)
INSERT INTO jobs 
VALUES ('Test_08', 100, 200);

SELECT MAX(job_id) 
FROM jobs;

-- ⚠️ ممکن است در محیط‌های چندکاربره دقیق نباشد.


-- استفاده از تابع @@IDENTITY برای دریافت آخرین مقدار Identity در همان جلسه و Scope (ممکن است از Trigger تأثیر بگیرد)
INSERT INTO jobs 
VALUES ('Test_09', 100, 200);

SELECT @@IDENTITY;


-- استفاده از تابع SCOPE_IDENTITY() که فقط آخرین Identity در Scope فعلی را برمی‌گرداند (مطمئن‌تر از @@IDENTITY)
INSERT INTO jobs 
VALUES ('Test_10', 100, 200);

SELECT SCOPE_IDENTITY();


-- استفاده از تابع IDENT_CURRENT برای دریافت آخرین Identity یک جدول خاص (مستقل از Scope و Session)
INSERT INTO jobs 
VALUES ('Test_11', 100, 200);

SELECT IDENT_CURRENT('jobs');


-- درج رکورد و دریافت job_id به کمک OUTPUT
INSERT INTO jobs (job_desc, min_lvl, max_lvl) 
OUTPUT inserted.job_id 
VALUES ('Test_12', 100, 200);

-- ✅ توصیه پرفورمنسی:
-- استفاده از OUTPUT برای دریافت مقادیر درج شده هم خواناتر است و هم در کوئری‌های پیچیده یا عملیات Bulk Insert مفیدتر و دقیق‌تر عمل می‌کند.



/* ============================================================
   4. 🧾 درج چندین رکورد با استفاده از OUTPUT برای مشاهده مقادیر درج‌شده
   ============================================================ */

INSERT INTO jobs
OUTPUT inserted.*
VALUES 
    ('Test_13', 100, 200), 
    ('Test_14', 100, 200),
    ('Test_15', 100, 200),
    ('Test_16', 100, 200);

-- 📌 این کوئری چندین رکورد را به‌صورت هم‌زمان در جدول `jobs` درج می‌کند.
-- 🔍 با استفاده از `OUTPUT inserted.*`، تمامی فیلدهای رکوردهای درج‌شده به‌صورت مستقیم نمایش داده می‌شوند.

-- ✅ توصیه پرفورمنسی:
-- این روش برای عملیات‌های Bulk Insert که نیاز به ثبت یا بررسی رکوردهای درج‌شده دارند بسیار مناسب است و نسبت به SELECT مجزا ایمن‌تر و دقیق‌تر عمل می‌کند.



-------------------------------------------------------------------------------



/* ============================================================
   5. 🧱 ایجاد جدول TitleAmount و درج داده با استفاده از INSERT...SELECT
   ============================================================ */


-- 🧼 حذف جدول در صورت وجود قبلی برای جلوگیری از خطا
DROP TABLE IF EXISTS TitleAmount;


-- 🏗️ ایجاد جدول جدید برای ذخیره اطلاعات فروش به‌ازای هر کتاب
CREATE TABLE TitleAmount (
    title_id VARCHAR(6),
    title VARCHAR(80),
    Amount MONEY
);


-- 👁️ مشاهده جدول خالی (قبل از درج اطلاعات)
SELECT * 
FROM TitleAmount;


-- 📊 جمع فروش (قیمت × تعداد) به‌ازای هر عنوان کتاب
SELECT t.title_id, title, SUM(qty * price) AS Amount
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title;


-- 💾 درج نتایج حاصل از کوئری بالا به جدول TitleAmount
INSERT INTO TitleAmount
SELECT t.title_id, title, SUM(qty * price) AS Amount
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title;


-- ✅ توصیه پرفورمنسی:
-- استفاده از INSERT...SELECT یکی از سریع‌ترین روش‌ها برای پر کردن جدول با داده‌های حاصل از JOIN و Grouping است.
-- در صورتی که هدف فقط ایجاد و پر کردن جدول باشد، می‌توان به جای این روش از SELECT INTO نیز استفاده کرد.



-------------------------------------------------------------------------------



/* ============================================================
   6. 🧠 درج داده‌ها با استفاده از CTE و مشاهده داده‌های درج‌شده با OUTPUT
   ============================================================ */

-- 🧠 استفاده از CTE برای محاسبه مجموع فروش برای هر عنوان کتاب
;WITH cte AS (
    SELECT t.title_id, title, SUM(qty * price) AS Amount
    FROM titles t
    INNER JOIN sales s ON s.title_id = t.title_id
    GROUP BY t.title_id, title
)

-- 💾 درج داده‌ها از CTE به جدول TitleAmount و نمایش آن‌ها با OUTPUT
INSERT INTO TitleAmount
OUTPUT inserted.*
SELECT * FROM cte;

-- ✅ نکات پرفورمنسی:
-- استفاده از CTE باعث خوانایی بیشتر کوئری و ماژولار شدن آن می‌شود.
-- ترکیب `INSERT ... OUTPUT` برای مشاهده داده‌هایی که درج شده‌اند مفید است، مخصوصاً در فرآیندهای تست و اشکال‌زدایی.



-------------------------------------------------------------------------------



/* ============================================================
   7. 🔧 درج مقدار دلخواه در ستون IDENTITY با استفاده از SET IDENTITY_INSERT
   ============================================================ */

-- 🔐 فعال‌سازی امکان درج مقدار مشخص برای فیلد Identity
SET IDENTITY_INSERT jobs ON;

-- 📌 درج رکورد با مقدار مشخص برای job_id
INSERT INTO jobs (job_id, job_desc, min_lvl, max_lvl)
VALUES (31, 'Test_08', 100, 200);

-- 🔒 غیرفعال‌سازی مجدد پس از درج
SET IDENTITY_INSERT jobs OFF;

-- ✅ نکات پرفورمنسی:
-- این قابلیت فقط برای یک جدول در هر زمان فعال می‌ماند.
-- استفاده از آن در اسکریپت‌های مهاجرت داده یا بازگردانی اطلاعات بسیار مفید است.



-------------------------------------------------------------------------------



/* ============================================================
   8. 🏗️ ساخت جدول با ستون IDENTITY و درج داده از طریق SELECT
   ============================================================ */

-- 📦 حذف جدول در صورت وجود قبلی
DROP TABLE IF EXISTS TitleAmount;

-- 🧱 ایجاد جدول جدید همراه با ستون خودافزایشی IDENTITY
CREATE TABLE TitleAmount (
    Id int IDENTITY,             -- ستون خودافزایشی برای شماره‌گذاری اتوماتیک
    title_id varchar(6),
    title varchar(80),
    Amount money
);

-- 📊 محاسبه مقدار فروش هر عنوان و درج در جدول جدید
SELECT t.title_id, title, SUM(qty * price) AS Amount
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title;

-- 📌 نکات پرفورمنسی:
-- استفاده از ستون IDENTITY برای ایجاد ردیف‌های یکتا بدون نیاز به مدیریت دستی IDها مفید است.
-- درج داده با SELECT مناسب برای ساخت سریع جداول گزارش‌گیری است.



-------------------------------------------------------------------------------



/* ============================================================
   9. ⚡ ساخت سریع جدول با استفاده از SELECT INTO
   ============================================================ */

-- 📦 حذف جدول قبلی در صورت وجود
DROP TABLE IF EXISTS TitleAmount;

-- 🧱 ایجاد جدول جدید همراه با درج داده‌ها با یک کوئری
-- بدون نیاز به استفاده از CREATE TABLE جداگانه
SELECT t.title_id, title, SUM(qty * price) AS Amount
INTO TitleAmount
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title;

-- 📌 نکات پرفورمنسی:
-- این روش بسیار سریع و کارآمد برای ایجاد جدول‌های موقت یا دائمی از نتایج گزارش‌گیری است.
-- SELECT INTO باعث می‌شود SQL Server خودش نوع داده‌ها را تشخیص دهد.
-- قابل استفاده برای انتقال سریع داده‌ها به محیط جدید یا تستی.
