

/*
    ============================================================
    جلسه ۱۱: توابع تحلیلی (Analytic Functions) و پنجره‌ها (Window Functions)
    ============================================================

    در این جلسه با مفاهیم پیشرفته‌ی SQL آشنا می‌شویم که تحت عنوان توابع تحلیلی شناخته می‌شوند.
    این توابع امکان محاسبه مجموع‌ها، رتبه‌بندی‌ها، مقایسه مقادیر سطری و
	محاسبات مبتنی بر گروه‌بندی بدون کاهش ردیف‌ها را فراهم می‌کنند.

    📌 مباحث مطرح شده در این جلسه:
    ------------------------------------------------------------
    1. توابع رتبه‌بندی: 
       ROW_NUMBER(), RANK(), DENSE_RANK(), NTILE()

    2. توابع تجمعی (Aggregate Functions) در کنار OVER():
       SUM(), AVG(), COUNT() و کاربردهای آن‌ها در PARTITION و ORDER

    3. مقایسه مقادیر هر ردیف با مقدار کلی یا میانگین با:
       - ساب‌کوئری‌ها
       - CROSS JOIN
       - OVER()

    4. محاسبه درصد مشارکت از کل (Share of Total) با CTE و OVER()

    5. نحوه استفاده از frame definitions در window functions:
       - ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       - تفاوت در IO و performance بررسی شده با `SET STATISTICS IO`

    6. تمرین عملی با AdventureWorks و یافتن رکوردهای خاص مانند:
       - پنجمین کتاب گران‌قیمت با RANK

    ✨ این جلسه قدمی مهم به سوی تحلیل‌های پیشرفته در SQL است و کاربردهای زیادی در گزارش‌گیری، داشبوردسازی و تحلیل‌های مالی دارد.
    ============================================================
*/




USE T_pubs
GO



/* ============================================================
   1. 📌 شبیه‌سازی شماره ردیف با ساب‌کوئری
   ============================================================

   🎯 این کوئری با استفاده از یک ساب‌کوئری، شماره ردیف را برای هر نویسنده بر اساس `au_id` محاسبه می‌کند.
   🧮 برای هر رکورد، تعداد نویسندگانی که `au_id` آن‌ها کمتر یا مساوی رکورد فعلی است، شمارش می‌شود.
*/

SELECT 
    (SELECT COUNT(*) 
     FROM authors a 
     WHERE a.au_id <= r.au_id) AS id,
    au_id,
    au_fname,
    au_lname
FROM authors r
ORDER BY au_id;

-- 📈 این روش در دیتاست‌های بزرگ ممکن است کارایی پایینی داشته باشد، زیرا برای هر ردیف، یک ساب‌کوئری اجرا می‌شود.
-- ✅ استفاده از توابع پنجره‌ای مانند `ROW_NUMBER()` به مراتب بهینه‌تر و خواناتر است.

/* ============================================================
   2. 🆚 مقایسه با ROW_NUMBER()
   ============================================================

   🎯 این کوئری از تابع پنجره‌ای `ROW_NUMBER()` برای اختصاص شماره ردیف به هر نویسنده استفاده می‌کند.
   🧾 شماره‌ها بر اساس ترتیب `au_id` تعیین می‌شوند.
*/

SELECT 
    ROW_NUMBER() OVER (ORDER BY au_id) AS id,
    au_id,
    au_fname,
    au_lname
FROM authors;

-- 🚀 این روش نسبت به ساب‌کوئری قبلی بسیار بهینه‌تر است و در دیتاست‌های بزرگ عملکرد بهتری دارد.
-- 📚 `ROW_NUMBER()` همیشه شماره‌های یکتا و متوالی تولید می‌کند، حتی در صورت وجود مقادیر تکراری.

/* ============================================================
   3. 🧮 استفاده از ROW_NUMBER() برای کتاب‌ها
   ============================================================

   🎯 این کوئری شماره ردیف را برای هر کتاب بر اساس `title_id` تعیین می‌کند.
   🧾 شماره‌ها بر اساس ترتیب `title_id` اختصاص می‌یابند.
*/

SELECT 
    ROW_NUMBER() OVER (ORDER BY title_id) AS id,
    title_id,
    title,
    type,
    price
FROM titles;

-- 📈 این روش برای شماره‌گذاری ردیف‌ها در گزارش‌ها و صفحات‌بندی بسیار مفید است.

/* ============================================================
   4. 🧩 استفاده از PARTITION BY با ROW_NUMBER()
   ============================================================

   🎯 این کوئری شماره ردیف را برای هر کتاب در هر نوع (`type`) به‌صورت جداگانه تعیین می‌کند.
   🧾 با استفاده از `PARTITION BY type`، شماره‌گذاری در هر گروه `type` مجزا انجام می‌شود.
*/

SELECT 
    ROW_NUMBER() OVER (PARTITION BY type ORDER BY title_id) AS id,
    title_id,
    title,
    type,
    price
FROM titles;

-- 📚 این روش برای تحلیل داده‌ها در گروه‌های مختلف بسیار کاربردی است.

/* ============================================================
   5. 🏅 استفاده از RANK() برای رتبه‌بندی بر اساس قیمت
   ============================================================

   🎯 این کوئری رتبه هر کتاب را بر اساس قیمت آن به‌صورت نزولی تعیین می‌کند.
   🧾 در صورت وجود قیمت‌های مساوی، رتبه یکسان اختصاص می‌یابد و رتبه بعدی با فاصله محاسبه می‌شود.
*/

SELECT 
    title_id,
    title,
    type,
    price,
    RANK() OVER (ORDER BY price DESC) AS Rank
FROM titles;

-- ⚠️ `RANK()` در صورت وجود مقادیر مساوی، رتبه‌ها را تکراری اختصاص می‌دهد و بین رتبه‌ها فاصله ایجاد می‌کند.
-- 📊 برای تحلیل‌هایی که نیاز به رتبه‌بندی با در نظر گرفتن فاصله دارند، مناسب است.

/* ============================================================
   6. 🧮 استفاده از DENSE_RANK() برای رتبه‌بندی بدون فاصله
   ============================================================

   🎯 این کوئری رتبه هر کتاب را بر اساس قیمت آن به‌صورت نزولی تعیین می‌کند.
   🧾 در صورت وجود قیمت‌های مساوی، رتبه یکسان اختصاص می‌یابد و رتبه بعدی بدون فاصله محاسبه می‌شود.
*/

SELECT 
    title_id,
    title,
    type,
    price,
    DENSE_RANK() OVER (ORDER BY price DESC) AS DenseRank
FROM titles;

-- ✅ `DENSE_RANK()` در صورت وجود مقادیر مساوی، رتبه‌ها را تکراری اختصاص می‌دهد اما بدون ایجاد فاصله بین رتبه‌ها.
-- 📈 برای تحلیل‌هایی که نیاز به رتبه‌بندی متوالی بدون فاصله دارند، مناسب است.

/* ============================================================
   7. 🧮 رتبه‌بندی در هر گروه نوع کتاب با RANK()
   ============================================================

   🎯 این کوئری رتبه هر کتاب را در گروه نوع (`type`) خود بر اساس قیمت به‌صورت نزولی تعیین می‌کند.
   🧾 با استفاده از `PARTITION BY type`، رتبه‌بندی در هر گروه `type` مجزا انجام می‌شود.
*/

SELECT 
    title_id,
    title,
    type,
    price,
    RANK() OVER (PARTITION BY type ORDER BY price DESC) AS Rank
FROM titles;

-- 📚 این روش برای مقایسه قیمت کتاب‌ها در هر نوع به‌صورت جداگانه بسیار مفید است.


/* ============================================================
   8. 📊 تقسیم‌بندی داده‌ها با NTILE()
   ============================================================

   🎯 این کوئری کتاب‌ها را بر اساس قیمت به چهار گروه تقسیم می‌کند.
   🧾 با استفاده از `NTILE(4)`, داده‌ها به چهار بخش تقریباً مساوی تقسیم می‌شوند.
*/

SELECT 
    title_id,
    title,
    type,
    price,
    NTILE(4) OVER (ORDER BY price DESC) AS Quartile
FROM titles;


------------------------------------------------------------------------------------

/* ============================================================
   9. 💵 محاسبه مجموع فروش برای هر عنوان
   ============================================================

   🎯 این کوئری مجموع درآمد حاصل از فروش هر عنوان کتاب را محاسبه می‌کند.
   🧾 گروه‌بندی بر اساس `title_id` و `title` انجام می‌شود.
*/

SELECT 
    t.title_id,
    title,
    SUM(qty * price) AS Amount
FROM titles t 
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY t.title_id, title;

-- 📊 روشی ساده و سنتی برای جمع‌بندی داده‌ها.
-- ⚡ عملکرد خوبی دارد اما در موارد خاص با OVER() می‌توان انعطاف بیشتری داشت.


/* ============================================================
   10. 🔁 استفاده از تابع پنجره‌ای SUM با PARTITION BY
   ============================================================

   🎯 این کوئری با استفاده از تابع پنجره‌ای، مجموع فروش برای هر عنوان را محاسبه می‌کند.
   🧾 با `PARTITION BY title_id`، مقدار مجموع برای هر عنوان در تمام ردیف‌ها تکرار می‌شود.
*/

SELECT DISTINCT
    t.title_id,
    title,
    SUM(qty * price) OVER (PARTITION BY t.title_id) AS Amount
FROM titles t 
INNER JOIN sales s ON s.title_id = t.title_id;

-- 🧮 مقدار مجموع به ازای هر `title_id` تکرار می‌شود بدون نیاز به GROUP BY.
-- ✅ مناسب برای زمانی که می‌خواهید مجموع فروش را در کنار داده‌های دیگر نشان دهید.
-- ⚠️ نیاز به DISTINCT برای جلوگیری از تکرار ردیف‌ها (در صورت وجود چند رکورد فروش برای یک عنوان).
		



/* ============================================================
   11. ➖ محاسبه اختلاف قیمت هر کتاب با میانگین کل
   ============================================================

   🎯 این کوئری تفاوت قیمت هر کتاب با میانگین قیمت کل کتاب‌ها را محاسبه می‌کند.
   🧾 از یک ساب‌کوئری در بخش `SELECT` استفاده شده است.
*/

SELECT 
    title_id,
    title,
    price - (SELECT AVG(price) FROM titles) AS PriceDiff
FROM titles;

-- 📉 روش ساده و مستقیم، اما اجرای ساب‌کوئری ممکن است برای هر ردیف تکرار شود.
-- ❗ در دیتاست‌های بزرگ ممکن است عملکرد مطلوبی نداشته باشد.


/* ============================================================
   12. ✖️ استفاده از CROSS JOIN برای بهبود عملکرد محاسبه
   ============================================================

   🎯 به‌جای اجرای ساب‌کوئری در هر ردیف، از `CROSS JOIN` برای الحاق میانگین قیمت به کل جدول استفاده شده.
*/

SELECT 
    title_id,
    title,
    price - AvgPrice AS PriceDiff
FROM titles 
CROSS JOIN (SELECT AVG(price) AS AvgPrice FROM titles) AS D;

-- 🚀 این روش معمولاً از نظر عملکرد بهتر از ساب‌کوئری در `SELECT` است.
-- ✅ مقدار میانگین فقط یک بار محاسبه شده و در تمام ردیف‌ها تکرار می‌شود.

/* ============================================================
   13. 🧠 استفاده از تابع پنجره‌ای AVG برای اختلاف قیمت
   ============================================================

   🎯 این کوئری اختلاف قیمت هر کتاب با میانگین کل را با استفاده از تابع پنجره‌ای محاسبه می‌کند.
   🧾 با استفاده از `AVG(price) OVER ()` میانگین در تمام ردیف‌ها تکرار می‌شود.
*/

SELECT 
    title_id,
    title,
    price - AVG(price) OVER () AS PriceDiff
FROM titles;

-- 📊 این روش از نظر خوانایی و عملکرد، تمیزتر از CROSS JOIN یا ساب‌کوئری است.
-- ✅ تابع پنجره‌ای بدون نیاز به GROUP BY یا JOIN میانگین را محاسبه می‌کند.


------------------------------------------------------------------------------------------


/* ============================================================
   14. 📈 محاسبه درصد سهم فروش ناشر با استفاده از CROSS JOIN
   ============================================================

   🎯 این کوئری مجموع فروش هر ناشر را محاسبه می‌کند و سپس سهم آن از کل فروش را به صورت درصدی نشان می‌دهد.
   🔄 از CTE برای محاسبه مجموع فروش ناشرها و از CROSS JOIN برای ضمیمه‌کردن مجموع کل فروش به هر ردیف استفاده شده.
*/

;WITH cte AS (
	SELECT P.pub_id, pub_name, SUM(qty * price) AS Amount
	FROM titles t
	INNER JOIN sales s ON s.title_id = t.title_id
	INNER JOIN publishers p ON p.pub_id = t.pub_id
	GROUP BY P.pub_id, pub_name
)

SELECT 
	cte.*,
	Amount / Total * 100 AS SharePublisher
FROM cte
CROSS JOIN (
	SELECT SUM(Amount) AS Total
	FROM cte
) AS TotalAmount;

-- ✅ با استفاده از CROSS JOIN فقط یک بار مجموع کل فروش محاسبه شده و سپس به تمام ردیف‌ها اعمال شده.
-- 🔧 عملکرد خوب دارد، به‌ویژه زمانی که داده‌ها زیاد نیستند یا نیاز به انعطاف در مرحله CROSS JOIN دارید.



/* ============================================================
   15. 📊 استفاده از تابع پنجره‌ای برای محاسبه سهم فروش ناشر
   ============================================================

   🎯 همانند کوئری قبلی، این کوئری نیز سهم فروش ناشر را محاسبه می‌کند، اما از تابع پنجره‌ای استفاده شده است.
   📈 استفاده از `SUM(Amount) OVER ()` مجموع کل فروش را در تمام ردیف‌ها تکرار می‌کند.
*/

;WITH cte AS (
	SELECT P.pub_id, pub_name, SUM(qty * price) AS Amount
	FROM titles t
	INNER JOIN sales s ON s.title_id = t.title_id
	INNER JOIN publishers p ON p.pub_id = t.pub_id
	GROUP BY P.pub_id, pub_name
)

SELECT 
	cte.*,
	Amount / SUM(Amount) OVER () * 100 AS SharePublisher
FROM cte;

-- 🚀 عملکرد بهتری نسبت به CROSS JOIN دارد، به‌ویژه در دیتاست‌های بزرگ.
-- 📦 تابع پنجره‌ای محاسبه را ساده و سریع می‌کند، بدون نیاز به الحاق دستی مجموع.



------------------------------------------------------------------------------------------------


-- ADVENTUREWORKS 2022



------------------------------------------------------------------------------------------------


USE T_AdventureWorks2022


------------------------------------------------------------------------------------------------


/* ============================================================
   16. 🔁 محاسبه تجمعی SubTotal با ترتیب بر اساس SalesOrderID
   ============================================================

   🎯 این کوئری مجموع تجمعی `SubTotal` را با استفاده از تابع پنجره‌ای `SUM(...) OVER(ORDER BY SalesOrderID)` محاسبه می‌کند.
   📊 کاربردی برای نمایش تجمعی فروش به ترتیب شناسه سفارش.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   SUM(SubTotal) OVER (ORDER BY SalesOrderID) AS RunningTotal
FROM Sales.SalesOrderHeader
ORDER BY OrderDate, SalesOrderID;

-- 🔍 اجرای ساده و خوانا.
-- 📈 بدون پارتیشن‌بندی، نتایج تجمعی کلی ایجاد می‌کند.


/* ============================================================
   17. 🧮 مقایسه مجموع تجمعی با و بدون پارتیشن‌بندی بر اساس OrderDate
   ============================================================

   🎯 در این کوئری دو نوع مجموع تجمعی محاسبه می‌شود:
      - بر اساس `SalesOrderID` در کل جدول
      - و پارتیشن‌بندی شده بر اساس `OrderDate`
   🔄 نمایش تفاوت در سطح تجمع برای تحلیل دقیق‌تر.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   SUM(SubTotal) OVER (PARTITION BY OrderDate) AS TotalPerDay,
	   SUM(SubTotal) OVER (ORDER BY OrderDate) AS CumulativeByDate
FROM Sales.SalesOrderHeader
ORDER BY OrderDate, SalesOrderID;

-- 🧠 مناسب برای تحلیل روزانه و مقایسه آن با رشد تجمعی کل.
-- ⚙️ تابع پنجره‌ای با پارتیشن‌بندی باعث دقت بیشتر در گروه‌بندی و آنالیز می‌شود.


/* ============================================================
   18. 🧮 مجموع تجمعی روزانه با ترتیب داخلی بر اساس SalesOrderID
   ============================================================

   🎯 این کوئری مجموع تجمعی `SubTotal` را برای هر روز (`OrderDate`) به ترتیب `SalesOrderID` محاسبه می‌کند.
   🧩 به شما امکان می‌دهد روند رشد فروش را در هر روز بررسی کنید.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   SUM(SubTotal) OVER (PARTITION BY OrderDate ORDER BY SalesOrderID) AS DailyRunningTotal
FROM Sales.SalesOrderHeader
ORDER BY OrderDate, SalesOrderID;

-- 📊 کاربردی برای نمایش روند تجمعی فروش در یک روز خاص.
-- ⚠️ این مدل تفکیک از نظر تحلیل دقیق‌تر ولی پیچیده‌تر است.

-----------------------------------------------------------------------------------------------

SET STATISTICS IO ON


/* ============================================================
   19. 📊 محاسبه تجمعی SubTotal با توابع پنجره‌ای - بدون محدوده
   ============================================================

   🎯 این کوئری از تابع پنجره‌ای `SUM(...) OVER (ORDER BY SalesOrderID)` استفاده می‌کند بدون تعیین بازه‌ی `ROWS`.
   ⚠️ به صورت پیش‌فرض برای تمام ردیف‌ها تا ردیف فعلی محاسبه می‌شود اما با IO بالا.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   SUM(SubTotal) OVER (ORDER BY SalesOrderID) AS RunningTotal
FROM Sales.SalesOrderHeader;

-- 🔍 پرفورمنس پایین‌تر (IO بیشتر) نسبت به استفاده از بازه‌های مشخص.
-- ❗ برای دیتابیس‌های بزرگ می‌تونه کند باشه.


/* ============================================================
   20. 📦 استفاده از UNBOUNDED PRECEDING تا UNBOUNDED FOLLOWING
   ============================================================

   🎯 این کوئری از `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` استفاده می‌کنه که کل جدول رو در هر بار محاسبه بررسی می‌کنه.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   SUM(SubTotal) OVER (ORDER BY SalesOrderID ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS TotalAll
FROM Sales.SalesOrderHeader;

-- ❌ عملکرد بسیار پایین‌تر به دلیل اسکن کامل جدول برای هر ردیف.
-- ⚠️ استفاده محدود توصیه می‌شود مگر در تحلیل‌هایی که نیازمند مقدار کلی هستند.


/* ============================================================
   21. 📉 افزایش پرفورمنس با محدودسازی دامنه تا ردیف فعلی
   ============================================================

   🎯 استفاده از `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` باعث بهبود چشمگیر در عملکرد کوئری می‌شود.
   🔄 تنها ردیف‌های قبلی تا ردیف فعلی در محاسبه شرکت دارند.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   SUM(SubTotal) OVER (ORDER BY SalesOrderID ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RunningTotal
FROM Sales.SalesOrderHeader;

-- ✅ IO پایین‌تر و سرعت بیشتر.
-- ✔️ توصیه‌شده برای محاسبات تجمعی در حجم داده‌های بزرگ.


/* ============================================================
   22. 🧮 محاسبه میانگین متحرک با دامنه مشخص
   ============================================================

   🎯 این کوئری از تابع `AVG(...) OVER (...)` برای محاسبه میانگین متحرک استفاده می‌کنه.
   🧠 بازه‌ی محاسبه از یک ردیف قبل تا یک ردیف بعد تنظیم شده.
*/

SELECT SalesOrderID, OrderDate, SubTotal,
	   AVG(SubTotal) OVER (ORDER BY SalesOrderID ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS MovingAverage
FROM Sales.SalesOrderHeader;

-- 📈 مناسب برای تحلیل داده‌های زمانی یا سری‌های عددی.
-- 💡 بازه مشخص باعث کاهش IO و بهینه‌سازی اجرا می‌شود.
	
-----------------------------------------------------------------------------------------------

USE T_pubs

-- تمرین
-- برنامه ای بنویسید که پنجمین کتاب گرون قیمت رو پیدا کنه و با دستور RANK



/* ============================================================
   23. 🏆 استخراج پنجمین کتاب گران‌قیمت با استفاده از RANK()
   ============================================================

   🎯 این کوئری قیمت کتاب‌ها را به صورت نزولی مرتب کرده و به هر کتاب یک رتبه (Rank) می‌دهد.
   🎯 سپس فقط کتاب‌هایی که رتبه آن‌ها دقیقاً ۵ است فیلتر می‌شوند، یعنی پنجمین کتاب گران‌قیمت.
*/

WITH RankedTitles AS (
	SELECT title_id, title, price,
		   RANK() OVER (ORDER BY price DESC) AS PriceRank
	FROM titles
)
SELECT title_id, title, price
FROM RankedTitles
WHERE PriceRank = 5;

-- 🎯 تابع RANK() در صورت وجود چند کتاب با یک قیمت مشابه، رتبه‌ها را با تکرار تخصیص می‌دهد.
-- ⚠️ اگر چند کتاب رتبه پنجم را کسب کنند، همه آن‌ها نمایش داده خواهند شد.
-- 📈 عملکرد خوب و خوانایی بالا با استفاده از CTE.


