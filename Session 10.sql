

/*
    ==========================================================
    جلسه ۱۰: مباحث پیشرفته در SQL Server
    ==========================================================

    در این جلسه، تکنیک‌های پیشرفته‌ای از SQL Server آموزش داده می‌شود
	که برای تحلیل داده‌ها، ساخت گزارش‌های حرفه‌ای، و مدیریت پیچیدگی‌های داده‌ کاربرد دارند.

    مباحثی که در این جلسه بررسی می‌شوند عبارت‌اند از:

    ----------------------------------------------------------

    ✅ استفاده پیشرفته از CASE برای اعمال چندین شرط تو در تو
    ✅ استفاده از CTE ساده و بازگشتی برای ساخت داده‌ها یا سلسله‌مراتب‌ها
    ✅ عملیات Set مانند UNION, INTERSECT, EXCEPT
    ✅ Pivot و Unpivot برای تغییر ساختار داده‌ها از سطر به ستون و بالعکس
    ✅ استفاده از ROLLUP و CUBE برای خلاصه‌سازی و تجمیع داده‌ها

    مثال‌ها با استفاده از دیتابیس‌های آموزشی `pubs` و `T_pubs` طراحی شده‌اند.

    ==========================================================
*/





/* ============================================================
   1. محاسبه قیمت جدید بر اساس چندین شرط با استفاده از CASE تو در تو
   ============================================================

   در این کوئری، برای هر کتاب در جدول `titles` یک قیمت جدید محاسبه می‌شود. 
   اولویت شرایط به صورت تو در تو تعریف شده است:
   - اگر ناشر آن در ایالت CA باشد → قیمت × 1.20
   - اگر کتاب بیش از یک نویسنده داشته باشد → قیمت × 1.15
   - اگر مجموع فروش آن بیش از 200 باشد → قیمت × 1.10
   - در غیر این صورت → قیمت × 0.99
*/
SELECT title_id, title, price,
       CASE 
           WHEN pub_id IN (SELECT pub_id FROM publishers WHERE state = 'CA') 
               THEN price * 1.20
           ELSE 
               CASE 
                   WHEN title_id IN (SELECT title_id FROM titleauthor GROUP BY title_id HAVING COUNT(*) > 1) 
                       THEN price * 1.15
                   ELSE 
                       CASE 
                           WHEN title_id IN (SELECT title_id FROM sales GROUP BY title_id HAVING SUM(qty) * price > 200)
                               THEN price * 1.10
                           ELSE price * 0.99
                       END
               END
       END AS NewPrice
FROM titles;


/* ============================================================
	2. محاسبه قیمت جدید با CASE ساده‌تر و استفاده از کوئری ترکیبی
   ============================================================
	 در این کوئری از JOIN و GROUP BY برای سادگی بیشتر و بهبود عملکرد استفاده شده است.
	 شرایط محاسبه قیمت جدید:
	 - ایالت CA → قیمت × 1.20
	 - بیش از ۱ نویسنده → قیمت × 1.15
	 - مجموع فروش بیش از ۲۰۰ → قیمت × 1.10
	 - در غیر این صورت → قیمت × 0.99
*/

SELECT t.title_id, title, price,
       CASE 
           WHEN state = 'CA' THEN price * 1.20
           WHEN CoAu > 1 THEN price * 1.15
           WHEN SUM(qty * price) > 200 THEN price * 1.10
           ELSE price * 0.99
       END AS NewPrice
FROM titles t
INNER JOIN publishers p ON p.pub_id = t.pub_id
INNER JOIN sales s ON s.title_id = t.title_id
INNER JOIN (
    SELECT title_id, COUNT(*) AS CoAu
    FROM titleauthor
    GROUP BY title_id
) a ON a.title_id = t.title_id
GROUP BY t.title_id, title, price, CoAu, state;


--------------------------------------------------------------------------------


/* ============================================================
   3. استفاده از CTE برای محاسبه تعداد نویسندگان هر کتاب
      و محاسبه قیمت جدید براساس شرایط مختلف
   ============================================================

   در این کوئری:
   - از CTE برای شمارش تعداد نویسندگان استفاده شده (cteCountAuthor).
   - قیمت جدید بر اساس سه شرط مختلف با اولویت:
     1. اگر ناشر در ایالت CA باشد → قیمت × 1.20
     2. اگر بیش از ۱ نویسنده داشته باشد → قیمت × 1.15
     3. اگر مجموع فروش بیش از ۲۰۰ باشد → قیمت × 1.10
     4. در غیر این صورت → قیمت × 0.99

   استفاده از CTE باعث وضوح بیشتر کوئری و بهبود خوانایی آن شده است.
*/
;WITH cteCountAuthor AS (
    SELECT title_id, COUNT(*) AS CoAu
    FROM titleauthor
    GROUP BY title_id
)
SELECT t.title_id, title, price,
       CASE 
           WHEN state = 'CA' THEN price * 1.20
           WHEN CoAu > 1 THEN price * 1.15
           WHEN SUM(qty * price) > 200 THEN price * 1.10
           ELSE price * 0.99
       END AS NewPrice
FROM titles t
INNER JOIN sales s ON s.title_id = t.title_id
INNER JOIN publishers p ON p.pub_id = t.pub_id
INNER JOIN cteCountAuthor c ON c.title_id = t.title_id
GROUP BY t.title_id, title, price, state, CoAu;


/* ============================================================
   4. شمارش تعداد نویسندگان برای هر کتاب بدون CTE
   ============================================================

   این کوئری فقط تعداد نویسندگان هر کتاب را با استفاده از INNER JOIN 
   بین جدول titles و titleauthor محاسبه می‌کند.
*/
SELECT t.title_id, title, COUNT(*) AS CoAu
FROM titles t
INNER JOIN titleauthor a ON a.title_id = t.title_id
GROUP BY t.title_id, title;



/* ============================================================
   5. 📘 شمارش تعداد نویسندگان 
			(CoAuthors)
			برای هر عنوان
   ============================================================

   🎯 این کوئری برای هر کتاب موجود در جدول `titles`، تعداد نویسندگانی که آن را نوشته‌اند (از جدول `titleauthor`) را محاسبه می‌کند.
   🔄 از یک ساب‌کوئری استفاده شده که `title_id`ها را گروه‌بندی کرده و آن‌ها را می‌شمارد.
*/

SELECT t.title_id, title, CoAu
FROM titles t 
INNER JOIN (
	SELECT title_id, COUNT(*) AS CoAu
	FROM titleauthor 
	GROUP BY title_id
) AS a ON a.title_id = t.title_id

-- 📊 مناسب برای گزارش‌گیری ساده از مشارکت نویسندگان.
-- ⚠️ ممکنه در دیتاست‌های بزرگ، پرفورمنس پایین‌تری نسبت به CTE داشته باشه.



/* ============================================================
   6. 🧩 استفاده از CTE برای محاسبه CoAuthors هر عنوان
   ============================================================

   🎯 این کوئری همانند قبلی است، اما از CTE (عبارت WITH) برای خوانایی بیشتر استفاده می‌کند.
   🛠️ CTE‌ها برای ساختاردهی کوئری‌های پیچیده، بسیار مناسب هستند.
*/

;WITH cte AS (
	SELECT title_id, COUNT(*) AS CoAu
	FROM titleauthor 
	GROUP BY title_id
)

SELECT t.title_id, title, CoAu
FROM titles t 
INNER JOIN cte c ON c.title_id = t.title_id

-- 📚 گزینه‌ی عالی برای ساختارمند کردن کوئری‌ها.
-- 🚀 در اجرای یک‌باره تفاوت زیادی با ساب‌کوئری نداره، اما در استفاده‌های چندباره مؤثرتره.



/* ============================================================
   7. ✍️ تعداد کتاب‌هایی که هر نویسنده نوشته است
   ============================================================

   🎯 این کوئری مشخص می‌کند که هر نویسنده چند عنوان کتاب نوشته.
   🧠 با استفاده از CTE اول تعداد کتاب‌ها محاسبه میشه و بعد به جدول `authors` متصل میشه.
*/

;WITH cte AS (
	SELECT au_id, COUNT(*) AS CoTi
	FROM titleauthor
	GROUP BY au_id
)

SELECT a.au_id, au_fname, au_lname, CoTi
FROM authors a
INNER JOIN cte c ON c.au_id = a.au_id

-- 📊 کاربردی برای گزارش‌گیری از نویسندگان.
-- 🧹 با CTE ساختار تمیز و خوانایی بالا برای کوئری فراهم شده.

-------------------------------------------

/* ============================================================
   8. 🎲 ایجاد داده‌های آزمایشی با حروف الفبای انگلیسی
   ============================================================

   🎯 این بخش با استفاده از یک جدول موقت (`#tbl`) داده‌هایی شامل حروف الفبای انگلیسی به همراه شناسه‌ی عددی‌شان تولید می‌کند.
   🔄 از یک حلقه `WHILE` استفاده شده تا حروف a تا z را به صورت خودکار وارد جدول کند.
*/

-- حذف جداول اگر از قبل وجود دارند
DROP TABLE IF EXISTS tbl_1
DROP TABLE IF EXISTS tbl_2
DROP TABLE IF EXISTS tbl_3
DROP TABLE IF EXISTS tbl_4
DROP TABLE IF EXISTS #tbl
GO 

-- ایجاد جدول موقت برای ذخیره حروف و شناسه‌ها
CREATE TABLE #tbl (
	Id int, 
	Char char(1)
)

-- پر کردن جدول با داده‌های حروف a تا z به همراه شناسه‌شان
DECLARE @i int = 97 
WHILE @i < 123
BEGIN 
	INSERT INTO #tbl VALUES (@i - 96 , CHAR(@i))
	SET @i += 1
END

-- 📦 این تکنیک برای تولید داده‌های تستی و شبیه‌سازی کاربردی است.
-- ⚠️ توجه داشته باشید که جدول موقت پس از پایان نشست حذف می‌شود.






/* ============================================================
   9. 🧪 ایجاد جداول آزمایشی و انجام عملیات JOIN
   ============================================================

   🎯 در این بخش با استفاده از داده‌های تولید شده در جدول موقت `#tbl`، چندین جدول دائمی `tbl_1` تا `tbl_4` ساخته می‌شود.
   🔄 داده‌ها شامل حروف الفبای انگلیسی هستند که در بازه‌های متفاوت تقسیم شده‌اند.
   سپس از `LEFT JOIN` برای نمایش تمام رکوردهای `tbl_1` همراه با رکوردهای منطبق در `tbl_2` استفاده شده است.
*/

-- کپی داده‌ها از جدول موقت به جدول دائمی tbl_1
SELECT * INTO tbl_1 FROM #tbl

-- حذف جدول موقت و ایجاد مجدد آن برای داده‌های جدید
DROP TABLE IF EXISTS #tbl
GO 

CREATE TABLE #tbl (
	Id int, 
	Char char(1)
)

-- درج داده‌های a تا i (حروف با کد 97 تا 109)
DECLARE @i int = 97 
WHILE @i < 110
BEGIN 
	INSERT INTO #tbl VALUES (@i - 96 , CHAR(@i))
	SET @i += 1
END

-- کپی داده‌های جدید به tbl_2
SELECT * INTO tbl_2 FROM #tbl

-- بار دیگر حذف و ایجاد جدول موقت برای داده‌های جدیدتر (j تا z)
DROP TABLE IF EXISTS #tbl
GO 

CREATE TABLE #tbl (
	Id int, 
	Char char(1)
)

DECLARE @i int = 110 
WHILE @i < 123
BEGIN 
	INSERT INTO #tbl VALUES (@i - 96 , CHAR(@i))
	SET @i += 1
END

-- کپی داده‌ها به tbl_3
SELECT * INTO tbl_3 FROM #tbl

-- کپی داده‌های tbl_1 به tbl_4 برای مقایسه‌های بعدی
SELECT * INTO tbl_4 FROM tbl_1

-- 🧩 نمایش همه رکوردهای tbl_1 همراه با رکوردهای منطبق از tbl_2
-- 📌 رکوردهایی که در tbl_1 وجود دارند ولی در tbl_2 نیستند، با مقادیر NULL در ستون‌های مربوط به tbl_2 نمایش داده می‌شوند.
SELECT *	
FROM tbl_1 
LEFT JOIN tbl_2 ON tbl_1.Id = tbl_2.Id

-- 📊 این بخش برای تمرین JOINها، تفکیک داده‌ها، و مقایسه‌ی مجموعه‌های داده استفاده می‌شود.






/* ============================================================
   10. ⚖️ استفاده از عملگرهای مجموعه‌ای (Set Operators)
   ============================================================

   🎯 در این بخش، عملکردهای `UNION`, `UNION ALL`, و `INTERSECT` برای ترکیب یا تقاطع داده‌ها از جداول مختلف بررسی می‌شوند.
*/

/* ------------------------------------------------------------
   🔁 UNION ALL: ترکیب تمام رکوردها از tbl_1 و tbl_2 (با تکراری‌ها)
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_1
UNION ALL 
SELECT *
FROM tbl_2

-- 📌 همه رکوردها از هر دو جدول نمایش داده می‌شوند حتی اگر تکراری باشند.
-- ✅ سریع‌تر از UNION چون نیاز به حذف رکوردهای تکراری ندارد.

/* ------------------------------------------------------------
   🔀 UNION: ترکیب رکوردهای غیر تکراری از tbl_1 و tbl_2
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_1
UNION 
SELECT *
FROM tbl_2

-- 📌 رکوردهای تکراری حذف می‌شوند.
-- ⚠️ نیاز به مرتب‌سازی داخلی دارد، بنابراین نسبت به UNION ALL کندتر است.

/* ------------------------------------------------------------
   🔁 UNION ALL برای ترکیب tbl_2 و tbl_3
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_2
UNION ALL
SELECT *
FROM tbl_3

-- 📌 شامل همه رکوردها با تکرار از هر دو جدول.

/* ------------------------------------------------------------
   🔀 UNION برای ترکیب بدون تکرار از tbl_2 و tbl_3
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_2
UNION 
SELECT *
FROM tbl_3

-- 📌 رکوردهای مشترک فقط یکبار نمایش داده می‌شوند.

/* ------------------------------------------------------------
   🔍 INTERSECT: تقاطع بین tbl_1 و tbl_2
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_1
INTERSECT
SELECT *
FROM tbl_2

-- 📌 فقط رکوردهایی که در هر دو جدول یکسان هستند نمایش داده می‌شوند.
-- ⚠️ از نظر پرفورمنسی سنگین‌تر از UNION ALL، چون باید مقایسه کامل انجام دهد.






/* ============================================================
   11. 🎯 استفاده از EXISTS، INTERSECT و EXCEPT برای مقایسه رکوردها
   ============================================================ */

/* ------------------------------------------------------------
   ✅ EXISTS: بررسی وجود رکورد مشابه بین tbl_1 و tbl_2
   ------------------------------------------------------------ */
SELECT *
FROM tbl_1 
WHERE EXISTS (
	SELECT * 
	FROM tbl_2 
	WHERE tbl_1.Id = tbl_2.Id AND tbl_1.Char = tbl_2.Char
)

-- 🔍 فقط رکوردهایی از tbl_1 نمایش داده می‌شود که در tbl_2 نیز با همان مقدار Id و Char وجود داشته باشند.
-- 🚀 پرفورمنس بالا در مقایسه با INTERSECT، مخصوصاً در وجود ایندکس.

/* ------------------------------------------------------------
   🔁 INTERSECT: یافتن رکوردهای مشترک بین tbl_3 و tbl_2
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_3
INTERSECT
SELECT *
FROM tbl_2

-- 📌 فقط رکوردهایی که در هر دو جدول دقیقاً مشابه هستند نمایش داده می‌شوند.

/* ------------------------------------------------------------
   ➖ EXCEPT: رکوردهای موجود در tbl_1 که در tbl_2 نیستند
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_1
EXCEPT
SELECT *
FROM tbl_2

-- 📌 نمایش رکوردهایی از tbl_1 که در tbl_2 وجود ندارند.

/* ------------------------------------------------------------
   ➖ EXCEPT برعکس: رکوردهای موجود در tbl_2 که در tbl_1 نیستند
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_2
EXCEPT
SELECT *
FROM tbl_1

-- 📌 مشابه قبل ولی این‌بار مقایسه از جهت tbl_2 انجام می‌شود.

/* ------------------------------------------------------------
   📎 مقایسه رکوردهای tbl_1 و tbl_4 که محتوای یکسانی دارند
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_1
EXCEPT
SELECT *
FROM tbl_4

-- ⚠️ انتظار می‌رود نتیجه خالی باشد چون tbl_4 کپی tbl_1 است.

/* ------------------------------------------------------------
   📎 بررسی تفاوت از جهت معکوس (tbl_4 به tbl_1)
   ------------------------------------------------------------ */
SELECT *	
FROM tbl_4
EXCEPT
SELECT *
FROM tbl_1

-- 📌 مشابه قبلی، اگر واقعاً کپی باشند خروجی نخواهد داشت.
	----------------------------------------------------

/*

;WITH cte
	AS 
		(SELECT * ..			-> Anchor
		UNION ALL 
		 SELECT * 
			FROM cte  
			WHERE Condition		-> Recursion)	
SELECT *
	FROM cte
*/


/* ============================================================
   12. 🔁 تولید دنباله عددی از 1 تا 10 با استفاده از CTE بازگشتی
   ============================================================

   🧩 این کوئری از قابلیت Recursive CTE استفاده می‌کند تا اعدادی از 1 تا 10 را تولید کند.
   ➕ ابتدا مقدار اولیه 1 ایجاد می‌شود و سپس با استفاده از UNION ALL مقادیر بعدی تا رسیدن به 10 افزوده می‌شوند.
*/

;WITH Number AS (
	SELECT 1 AS n            -- 🔹 مقدار اولیه: شروع از 1
	UNION ALL
	SELECT n + 1             -- 🔁 افزایش مقدار در هر تکرار
	FROM Number
	WHERE n < 10            -- ⛔ شرط توقف: زمانی که n به 10 برسد
)

SELECT * 
FROM Number

-- 📌 این تکنیک برای ساخت جداول تقویم، تولید ردیف‌ها، تکرارهای محاسباتی و بسیاری از عملیات دنباله‌ای در SQL بسیار کاربردی است.
-- ⚠️ توجه: برای استفاده از CTE بازگشتی، باید گزینه maxrecursion تنظیم باشد (پیش‌فرض 100).





/* ============================================================
   13. 🌍 ساختار سلسله‌مراتبی مناطق با استفاده از CTE بازگشتی
   ============================================================

   📌 ابتدا ساختار جدول Area ایجاد می‌شود که هر منطقه (Area) می‌تواند یک والد (Parent) داشته باشد.
   📥 داده‌ها به صورت سلسله‌مراتبی وارد می‌شوند. مثلا "Tehran" زیرمجموعه "Iran" است.

   🎯 هدف: تولید مسیر کامل هر منطقه (Path) همراه با عمق آن (Level) در ساختار درختی.
*/

USE T_pubs
GO

DROP TABLE IF EXISTS Area
GO

CREATE TABLE Area (
	AreaID int PRIMARY KEY,	
	AreaName varchar(50),
	ParentID int FOREIGN KEY REFERENCES Area(AreaID)
)
GO	

-- 🧾 درج داده‌ها به صورت درختی
INSERT INTO AREA VALUES 
(1, 'Iran', NULL),
(2, 'Iraq', NULL),
(3, 'Tehran', 1),
(4, 'Baghdad', 2),
(5, 'Fars', 1),
(6, 'Tehran', 3),
(7, 'Lavasan', 3),
(8, 'Shiraz', 5),
(9, 'Laar', 5),
(10, 'Mirdamad', 6),
(11, 'GhasrDasht', 8)
GO

SELECT * FROM Area


-- ✅ ساخت ساختار درختی با CTE بازگشتی
;WITH cteArea AS (
	SELECT 
		AreaID, 
		AreaName, 
		1 AS Level, 
		CAST(AreaName AS nvarchar(MAX)) AS Path
	FROM Area
	WHERE ParentID IS NULL  -- 🔹 ریشه‌های درخت (بدون والد)

	UNION ALL

	SELECT 
		a.AreaID,
		a.AreaName,
		c.Level + 1,
		c.Path + '/' + a.AreaName
	FROM Area a
	INNER JOIN cteArea c ON c.AreaID = a.ParentID
)

-- 🎯 نمایش تمام مناطق با مسیر کامل و سطح آن‌ها
SELECT * 
FROM cteArea

-- 📊 این تکنیک برای تحلیل درخت‌های سازمانی، مناطق جغرافیایی، ساختارهای دسته‌بندی محصولات و... کاربرد دارد.


/* ============================================================
   14. 📅 استخراج سال فروش از تاریخ سفارش‌ها
   ============================================================

   🎯 این کوئری فقط ستون تاریخ سفارش و سال مربوط به آن را نمایش می‌دهد.
   ✅ از تابع `YEAR()` برای استخراج سال از فیلد `ord_date` استفاده شده است.
*/

SELECT ord_date, YEAR(ord_date)
FROM sales;



/* ============================================================
   15. 💰 جمع فروش سالانه بر اساس نوع کتاب
   ============================================================

   🎯 این کوئری برای محاسبه مجموع فروش بر اساس سال و نوع کتاب استفاده می‌شود.
   🔄 ابتدا `titles` و `sales` با هم JOIN شده‌اند، سپس فروش به تفکیک سال و نوع کتاب گروه‌بندی شده‌اند.
*/

SELECT type, YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
FROM titles t 
INNER JOIN sales s ON s.title_id = t.title_id
GROUP BY type, YEAR(ord_date);



/* ============================================================
   16. 📊 استفاده از PIVOT برای نمایش فروش سالانه در ستون‌های جداگانه
   ============================================================

   🎯 این کوئری خروجی جدول قبل را به شکل ستونی بازآرایی می‌کند.
   📦 از `PIVOT` برای تبدیل سال‌ها به ستون و نمایش مجموع فروش در هر ستون استفاده شده است.
*/

SELECT *
FROM (
	SELECT type, YEAR(ord_date) AS Year, (qty * price) AS Amount
	FROM titles t 
	INNER JOIN sales s ON s.title_id = t.title_id
) AS DQ
PIVOT (
	SUM(Amount) FOR Year IN ([1992], [1993], [1994])
) AS PQ;

-- 🧮 خروجی نهایی: جدول با نوع کتاب‌ها به عنوان ردیف و سال‌های فروش به عنوان ستون
-- 📌 تکنیک PIVOT برای ساخت داشبورد و گزارش‌های سالانه بسیار کاربردی است.



------------------------------------------------------
/* ============================================================
   17. 📊 استفاده از PIVOT برای نمایش فروش سالانه ناشرین
   ============================================================

   🎯 این کوئری مجموع فروش ناشرها را به تفکیک سال در ستون‌های جداگانه نشان می‌دهد.
   🔄 ابتدا `titles`، `sales` و `publishers` با هم JOIN شده‌اند و سپس با استفاده از PIVOT داده‌ها بازآرایی شده‌اند.
   ✅ از `ISNULL` برای جلوگیری از نمایش مقدار NULL در ستون‌های سال‌ها استفاده شده است.
*/

SELECT pub_id, pub_name, 
	   ISNULL([1992], 0) AS [1992], 
	   ISNULL([1993], 0) AS [1993], 
	   ISNULL([1994], 0) AS [1994]
FROM (
	SELECT p.pub_id, pub_name, YEAR(ord_date) AS Year, (qty * price) AS Amount
	FROM titles t 
	INNER JOIN sales s ON s.title_id = t.title_id 
	INNER JOIN publishers p ON p.pub_id = t.pub_id
) AS DQ
PIVOT (
	SUM(Amount) FOR Year IN ([1992], [1993], [1994])
) AS PQ;

-- 🧮 نمایش گزارش تجمیعی فروش ناشران در قالب ستون‌های سالانه
-- 📦 مناسب برای ساخت گزارش‌های مدیریتی با خوانایی بالا



/* ============================================================
   18. 🔄 تبدیل گزارش PIVOT به ساختار سطری با UNPIVOT
   ============================================================

   🎯 این کوئری برعکس قبلی عمل می‌کند، یعنی ستون‌های سال را به ردیف‌ها تبدیل می‌کند.
   🛠️ از `UNPIVOT` برای تبدیل داده‌های ستونی به سطری استفاده شده است.
   📦 مناسب برای تحلیل سالانه به صورت خطی و مقایسه‌ای
*/

SELECT *
FROM PublishersPivot
UNPIVOT (
	Amount FOR Year IN ([1992], [1993], [1994])
) AS UQ;

-- 🔁 تبدیل ساختار جدول از حالت ستونی (Pivot) به سطری (Unpivot)
-- 📊 مفید برای استفاده در نمودارهای خطی یا آنالیزهای مقایسه‌ای بر اساس سال


/* ============================================================
   19. 📈 استفاده از ROLLUP برای گزارش تجمیعی فروش ناشران
   ============================================================

   🎯 این کوئری مجموع فروش ناشرها را در هر سال و در مجموع نمایش می‌دهد.
   🔄 با استفاده از `WITH ROLLUP`، مجموع‌های سطح بالا (Grand Total و Subtotal) نیز در خروجی نمایش داده می‌شوند.
*/

SELECT pub_name, YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
FROM titles t 
INNER JOIN sales s ON s.title_id = t.title_id 
INNER JOIN publishers p ON p.pub_id = t.pub_id
GROUP BY pub_name, YEAR(ord_date)
WITH ROLLUP;

-- 📊 خروجی شامل ردیف‌های اضافی برای مجموع سالانه و کل مجموع است.
-- 🔍 مناسب برای گزارش‌هایی که تحلیل در سطوح مختلف نیاز دارند.



/* ============================================================
   20. 🧾 تجمیع داده‌ها به ترتیب سال سپس ناشر با ROLLUP
   ============================================================

   🎯 مشابه کوئری قبل، اما ترتیب گروه‌بندی ابتدا بر اساس سال و سپس نام ناشر است.
   🔁 تغییر ترتیب فیلدهای GROUP BY باعث تفاوت در سطح‌بندی نتایج ROLLUP می‌شود.
*/

SELECT YEAR(ord_date) AS Year, pub_name, SUM(qty * price) AS Amount
FROM titles t 
INNER JOIN sales s ON s.title_id = t.title_id 
INNER JOIN publishers p ON p.pub_id = t.pub_id
GROUP BY YEAR(ord_date), pub_name
WITH ROLLUP;

-- 📂 تحلیل فروش در هر سال با جزئیات ناشر، همراه با جمع کل برای هر سال و همه‌ی سال‌ها



/* ============================================================
   21. 🧮 استفاده از CUBE برای تمام ترکیب‌های تجمیع
   ============================================================

   🎯 این کوئری با استفاده از `WITH CUBE` تمام ترکیب‌های ممکن از سال و ناشر را تجمیع می‌کند.
   🧊 برخلاف ROLLUP، `CUBE` تمام مسیرهای گروه‌بندی را به طور کامل پوشش می‌دهد.
*/

SELECT pub_name, YEAR(ord_date) AS Year, SUM(qty * price) AS Amount
FROM titles t 
INNER JOIN sales s ON s.title_id = t.title_id 
INNER JOIN publishers p ON p.pub_id = t.pub_id
GROUP BY pub_name, YEAR(ord_date)
WITH CUBE;

-- 🌐 مناسب برای داشبوردهای تحلیلی که به انواع جمع‌های ممکن نیاز دارند.
-- ⚠️ ممکن است در داده‌های بزرگ منجر به افزایش زمان اجرا شود.


